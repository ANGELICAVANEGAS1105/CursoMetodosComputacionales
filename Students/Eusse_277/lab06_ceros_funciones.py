# -*- coding: utf-8 -*-
"""Lab06_ceros_funciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XiBnXePTppzFi3olSeeZuJ55Llbaodbx

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab06_ceros_funciones.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Codigo Markdown:
Los numeras a, b, c y d tiene que ver con escritura en código Markdown y comandos de latex: 

a. Escriba en pseudocódigo los pasos para aplicar el método de la bisección.

b. Realice la deducción del metodo de Newton-Rapshon, se recomienda escribir las ecuaciones en formato latex, para ello puede emplear las siguientes expresiones:

c. ¿Cuál es la diferencia del metodo de Newton-Rapson con respecto al de la secante?


d. Escriba en pseudocódigo los pasos para aplicar el método Punto Fijo.



Comentarios para escribir en latex

*   Entre simbolos \$ \$, puedes porner expresiones  puede poner expresiones, ejemplo:  $y = a_0 x^2 + b_1$  

*  Las funciones pueden ser definidas entre \\$,  poniendo un \\, antes de la funcion ejemplo: \\$ \\sinx \\$,   asi las funciones quedarian de esta manera : 

> $\sin x$, $\tan x$, $\sec x$, $\sqrt{a} $, $\frac{a}{b}, \frac{df}{dt}$

* Puedes generar tambien escribir ecuaciones con la instrucción:

  \\begin{equation} 

    \\sin x  
  
  \\end{equation}

Ejemplo:

  \begin{equation} 
    \frac{df}{dx} = \sin x  
  \end{equation}

# a) Escriba en pseudocódigo los pasos para aplicar el método de la bisección.

###**Algoritmo** Método de la biseccion


 **Inicio**  
 Entradas $f$, a, b, Nmax, tol
  
  1. fa $\leftarrow$ $f(a)$ 

  2. **Si** fa=0 **entonces**:  

     " a es raiz aproximada"  
   parar  
   **fin si**

3. fb $\leftarrow$ $f(b)$  
4. **Si** fb=0  **entonces**  

  "b es raiz aproximada"  
  parar  
  **fin si**   

5. **Si** (fb>0 & fa>0) || (fb<0 & fa<0) **entonces**  
parar  
  **fin si**  

6. error $\leftarrow$ b - a  
7. c $\leftarrow$ ( a + b )/2  
8. fc $\leftarrow$$f(c)$  
9. k$\leftarrow$1

10. **Mientras** k<= Nmax & error>tol & fc!=0 **hacer**  

  aux$\leftarrow$c  

  **Si** (fb>0 & fa<0)||(fb<0 & fc>0) **entonces**  
     b$\leftarrow$c  
     fb$\leftarrow$fc  
     **sino**:  
     a$\leftarrow$c  
     fa$\leftarrow$fc  
     **fin si.**  
     c$\leftarrow$ (a+b)/2  
     fc$\leftarrow$$f(c)$  
     error$\leftarrow$ \| c-aux \|  
     k$\leftarrow$ k+1  
     **Fin mientras**  
11.  **Si** fc=0 **entonces**  
   " raiz aproximada x=c"  
   **Sino** **Si** error<= tol **entonces**  
   " Raiz aproximada x=c con error = error"  
   **sino**  
   "Superado el numero maximo de iteraciones"  
   parar  
   **fin si**

### FIN

# b) Realice la deducción del metodo de Newton-Rapshon, se recomienda escribir las ecuaciones en formato latex.  

Consideremos la ecuacion $f(x)=0$ supongamos que posee solo una solución $α$ ∈ [ $a$, $b$ ]. Partimos de $x_{0}$ suficientemente cercano a la raiz podemos escribir:  

\
  $$f(α)= f(x_{0}) + (α-x_{0}) f'(x_{0}) + \frac{(α-x_{0})^{2}}{dx}f''(x_{0}+θh) $$  
  con $0< θ < 1$, $h=α - x_{0} $.


  Suponiendo que $f'(x)$ no se anulan en $[a, b]$ y que la diferencia  $α-x_{0}$ es muy pequeña, el metodo de Newton_ Raphson  consiste en despreciar el sumando $(α-x_{0})^{2}$  del desarrollo anterior, quedandonos con la aproximacion:  
  $$f(α)\cong f(x_{0})+(α-x_{0})f'(x_{0})$$  
  Como α es la solucion de la ecuacion $f(x)=0$ se tiene que $f(α)=0$ y por tanto, de la expresion anterior se sigue  que:  
  $$ f(x_{0}) + (α-x_{0})f'(x_{0}) $$   
  y despejando α resulta:  
  $$ α\cong x_{0}- \frac{f(x_{0})}{f'(x_{0})}$$  
  Así pues, si se parte de un valor $x_{0}$ proximo a $α $, el valor $x_{1}$ obtenido de esta forma proporciona un valor también próximo a la raíz $α$. Bajo determinadas condiciones(las veremos en un momento) ocurre que $x_{1}$ está más próximo a $α$ que $x_{0}$ En tales condiciones, como $x_{1}$ es un valor más cercano a la solución $α$ que $x_{0}$, podemos repetir el razonamiento anterior para acercarnos aún más a $α$, partiendo ahora de $x_{1}$ . Ello nos conduce a una segunda aproximación:  
  $$x_{2}= x_{1}-\frac{f(x_{1})}{f'(x_{1})} $$  
  De la misma manera podemos obtener una nueva (y mejor) aproximación  $x_{3}$ a partir de $x_{2}$.  
  $$ x_{3}= x_{2}-\frac{f(x_{2})}{f'(x_{2})}$$  
  El proceso puede seguir repitiéndose sucesivamente hasta encontrar un $x_{k}$ lo suficientemente proximo  a la raiz $α$.


  El algoritmo de Newton-Raphson consiste entonces en partir de una aproximación inicial $x_{0}$, y generar recursivamente la suceción $\{x_{i}\}_{i=1}^{n}$ con la formula recurrente:  
  $$x_{i+1}= x_{i}- \frac{f(x_{i})}{f'(x_{i})} $$  
  El algoritmo parará en aquél valor $i$
 para el que la diferencia $\| x_{i+1}-x_{i}\|$ sea lo suficientemente pequeña

# 2. Ceros de funciones
*Encontrar* los ceros de $e^{x}-2= \cos(e^x-2)$ por diferentes metodos, bisection, newton-rapshon, punto fijo.

#3. Partícula en reposo
Una particula parte del reposo sobre un plano inclinado uniforme, cuyo ángulo 
$\theta$ cambia con una rapidez constante de : 

\begin{equation}
\frac{\mathrm{d}\theta}{\mathrm{d} t} = \omega < 0
\end{equation}

Al final de t segundos, la posición del objeto esta dada por: 


\begin{equation}
x(t) = -\frac{g}{2\omega^2} \left( \frac{e^{\omega t}-e^{-\omega t}}{2}-\sin\omega t\right) 
\end{equation}

#3.  Area 
Hallar el área de un segmento circular cuya area sea igual a una cuarta parte del área del circulo. Para la solución se sugiere lo siguiente:

a) Encontrar la ecuacion trascendental.

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python.

c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre $[-2\pi, 2\pi]$. Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2*np.pi, 2*np.pi, 1000 )

d) Construir una segunda columna titulada "F_theta" con los registros f(theta)

f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz.

Estime el valor del ángulo empleando los siguientes metodos(Emplee  la documentacion):

g) [Bisección](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html)

h) [Newton-Rapshon](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)

i) [Secante](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) 

j) [Punto Fijo](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html)

# 3. Movimiento de proyectiles en presencia de viento.

Supongamos que un proyectil es lanzado desde el origen con una rapidez $v=vo( \cos \theta , \sin \theta $. Supongamos además que el efecto del viento sobre el proyectil es el de una fuerza proporcional a la velocidad relativa entre el viento y el proyectil. Teniendo presente que si u es la velocidad del viento y $\alpha$ el ángulo que hace dirección de esta velocidad con el eje x, se puede entrontrar las siguientes ecuaciones diferenciales, asociada al estado de movimiento del [proyectil](https://iopscience.iop.org/article/10.1088/0143-0807/36/2/025016/meta):


\begin{equation}
m\frac{dv_x}{dt} = -mb(v_x-u\cos \alpha )
\end{equation}

\begin{equation}
m\frac{dv_y}{dt} = -mg-mb(v_x-u\sin \alpha ),
\end{equation}

donde b es el párametro de rozamiento. La soluciones a las ecuaciones anteriores vienen dadas por:

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}

Ver imagen:  http://www.sc.ehu.es/sbweb/fisica3/fluidos/viento/parabolico.html


0. Establezca las siguietnes condiciones inciales.

```
#Parametros iniciales

v0 = 60 #Velocidad en m/s
alpha = np.pi #Angulo del viento
theta = np.deg2rad(45) #Angulo de lanzamiento
u = v0/2             #rapidez del viento
b = 0.05             #Parametro de friccion 
g = 9.8                #Aceleracion de la gravedad m/s2

Params = (alpha, v0, b, u,g)  #Parametros en tupla.

```



1. Defina dos funciones, una para x y otra para y. 

```

#Posicion en x
def pos_x(t, theta, alpha, v0, b, u,g):
  x = #escriba aca la expresión
  return x

#Posicion en y
def pos_y(t, theta, alpha, v0, b, u,g):


  y = #escriba aca la expresión
  return y 

```

2. Construya un diccionario con las claves "X", "Y", "Tiempo"

3. Con el diccionario construya un data frame de pandas llamado df con los nombres de columnas "X", "Y", "Tiempo"  https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html. Defina 1000 regitros para el intervalo de tiempo elegido.


4. Realice un gráfico de x como función del tiempo, de y como función del tiempo y la trayectoria de la partícula (df["X"], df["tiempo"], df["Y"]).


5. Determine el alcance máximo de la partícula, para ello tome  la solucion teórica con $y=0$, solucione numéricamente la ecuación para t y remplace este valor en la ecuación para x. Resuelvalo para $\theta=45^{o}$.  

6. Construya una  grafica del alcance máximo R como función de $\theta$, varie $\theta$  entre 10 y 80 grados cada 5 grados.

# 4. Construir un fractal empleando el metodo de Newton-Raphson, 
(Reproducir código y entender)
\begin{equation}
z_{n+1} = z_n -a \frac{f(z)}{f'(z)} 
\end{equation}



\begin{equation}
f'(z) = \frac{ f(z+h)+f(z) }{h}
\end{equation}

```
import numpy as np
import matplotlib.pylab as plt
from PIL import Image

Npx_X = 80 #Numero de pixeles en x
Npx_Y = 80 #Numero de pixeles en y

image = Image.new("RGB", (Npx_X, Npx_Y)) #Creacion de la imagen inicial

npx = np.arange(0, Npx_X)
npy = np.arange(0, Npx_Y)

xmin = -1
xmax = 1
ymin = -1
ymax = 1
#Transformación al plano complejo en un rectangulo (xmin, xmax), (ymin, ymax)
zx = npx * (xmax - xmin) / (Npx_X - 1)   + xmin
zy = npy * (ymax-ymin) / (Npx_Y - 1) + ymin

#Definicion  la funcion y las derivada 
def f(z): 
  return z**3 - 1

def fp(z): 
  return 3*z**2

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)
```

# Punto 4
"""

import numpy as np
import matplotlib.pylab as plt
from PIL import Image

Npx_X = 100 #Numero de pixeles en x
Npx_Y = 100 #Numero de pixeles en y

image = Image.new("RGB", (Npx_X, Npx_Y)) #Creacion de la imagen inicial

npx = np.arange(0, Npx_X)
npy = np.arange(0, Npx_Y)

xmin = -1
xmax = 1
ymin = -1
ymax = 1

# Transformación al plano complejo en un rectangulo (xmin, xmax), (ymin, ymax)
zx = npx * (xmax - xmin) / (Npx_X - 1)   + xmin
zy = npy * (ymax-ymin) / (Npx_Y - 1) + ymin

# Definicion  la funcion y las derivada 
def f(z): 
  return z**3 - 1

def fp(z): 
  return 3*z**2

h = 1E-4

def fpn(z, h): 
  return (f(z+h)-f(z))/h

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1

for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)

      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fpn(Z_0,h)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )  
      #print(i)
      #print(i)



plt.imshow(image)

"""# Punto 2 Ceros de funciones

# 2. Ceros de funciones  
Encontrar los ceros de  $e^x−2=cos(e^x−2)$  por diferentes metodos, bisection, newton-rapshon, punto fijo.
"""

from scipy import optimize

def trasendente(x):
  T1= np.cos(np.exp(x)-2)
  T2 = -np.exp(x)+2
  return T1+T2

x  =  np.linspace(0,10,100)
plt.figure(figsize=(10,10))
plt.grid()
#plt.xlim(4.4,6)
plt.plot(x, trasendente(x))

trasendente(0)

bicec_root = optimize.bisect(trasendente, 0, 4)# Con el metodo de la biseccion 
bicec_root
print(trasendente(bicec_root))

Newton_root = optimize.newton(trasendente, 4) # Con el metodo de Newton
Newton_root
print(trasendente(Newton_root))

x0= 4
punt_fijo= optimize.fixed_point(trasendente,x0) # Con metodo de punto fijo
trasendente(punt_fijo)

"""# Puento 3 área

3. Partícula en reposo
Una particula parte del reposo sobre un plano inclinado uniforme, cuyo ángulo 
$\theta$ cambia con una rapidez constante de : 

\begin{equation}
\frac{\mathrm{d}\theta}{\mathrm{d} t} = \omega < 0
\end{equation}

Al final de t segundos, la posición del objeto esta dada por: 


\begin{equation}
x(t) = -\frac{g}{2\omega^2} \left( \frac{e^{\omega t}-e^{-\omega t}}{2}-\sin\omega t\right) 
\end{equation}

###3.  Area 
Hallar el área de un segmento circular cuya area sea igual a una cuarta parte del área del circulo. Para la solución se sugiere lo siguiente:

a) Encontrar la ecuacion trascendental.

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python.

c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre $[-2\pi, 2\pi]$. Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2*np.pi, 2*np.pi, 1000 )

d) Construir una segunda columna titulada "F_theta" con los registros f(theta)

f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz.

Estime el valor del ángulo empleando los siguientes metodos(Emplee  la documentacion):

g) [Bisección](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html)

h) [Newton-Rapshon](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)

i) [Secante](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) 

j) [Punto Fijo](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html)
θ
"""

import math
import pandas as pd

def f(θ,R): # Parte a) funcion del area
  return (R**2/2)*(θ-np.sin(θ))

fun = lambda θ,R: f(θ,R)+ ((R**2)/2)*(math.sin(θ) - θ)# parte b) defunir una fuincion $f(θ)= 0$
fun(30,10)
θ = np.linspace(-2*np.pi, 2*np.pi, 1000 )
area = {'θ': np.linspace(-2*np.pi, 2*np.pi, 1000 ), 'F_theta': f(θ,1)}

df= pd.DataFrame(area)# Esta es la parte c) y d)


plt.figure(figsize=(8,8))
plt.grid()
plt.plot(df['F_theta'],df['θ']) # parte f)

f_raiz_b= optimize.bisect(f,-1,1,(1)) # Biseccion
f(f_raiz_b,1)

x0=0.5
f_raiz_N_R= optimize.newton(f,x0, args=(1,),maxiter=100)
f(f_raiz_N_R,1)

def method_secan(x0,x1): # este es el Metodo de la secante
  x_n2= np.zeros(10)
  x_n2[0]=x0
  x_n2[1]= x1
  i=3
  
  while True:
    
    x_n2[i-1]= x_n2[i-2]-((x_n2[i-2]-x_n2[i-3])/(f(x_n2[i-2],1)-f(x_n2[i-3],1)))*f(x_n2[i-2],1)

    if round(x_n2[i-1],5) == round(x_n2[i-2],5):
        break
    else:
        i += 1
  return x_n2[i-1]

method_secan(1,-1)# Metodo de la secante

f(method_secan(1,-1),1)

x0= 4
raiz_punt_fijo= optimize.fixed_point(f,x0, args=(1,))
f(raiz_punt_fijo,1)

"""# 3. Movimiento de proyectiles en presencia de viento.

Supongamos que un proyectil es lanzado desde el origen con una rapidez $v=vo( \cos \theta , \sin \theta $. Supongamos además que el efecto del viento sobre el proyectil es el de una fuerza proporcional a la velocidad relativa entre el viento y el proyectil. Teniendo presente que si u es la velocidad del viento y $\alpha$ el ángulo que hace dirección de esta velocidad con el eje x, se puede entrontrar las siguientes ecuaciones diferenciales, asociada al estado de movimiento del [proyectil](https://iopscience.iop.org/article/10.1088/0143-0807/36/2/025016/meta):


\begin{equation}
m\frac{dv_x}{dt} = -mb(v_x-u\cos \alpha )
\end{equation}

\begin{equation}
m\frac{dv_y}{dt} = -mg-mb(v_x-u\sin \alpha ),
\end{equation}

donde b es el párametro de rozamiento. La soluciones a las ecuaciones anteriores vienen dadas por:

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}

Ver imagen:  http://www.sc.ehu.es/sbweb/fisica3/fluidos/viento/parabolico.html


0. Establezca las siguietnes condiciones inciales.
"""

v0 = 60 #Velocidad en m/s
alpha = np.pi #Angulo del viento
theta = np.deg2rad(45) #Angulo de lanzamiento
u = v0/2             #rapidez del viento
b = 0.05             #Parametro de friccion 
g = 9.8                #Aceleracion de la gravedad m/s2

Params = (alpha, v0, b, u,g)  #Parametros en tupla.

# Posicion en x
def pos_x(t, theta, alpha, v0, b, u,g):
  T1= (u*np.cos(alpha))*t
  T2= (1/b)*((v0*np.cos(theta))-(u*np.cos(alpha)))*(1-np.exp(-(b*t)))
  x = T1 + T2 #escriba aca la expresión
  return x

# Posicion en y
def pos_y(t, theta, alpha, v0, b, u,g):
  T1= t*((g/b)-u*np.sin(alpha))

  T2= g/b + v0*np.sin(theta)-u*np.sin(alpha)

  T3= 1 -np.exp(-(b*t))

  y =1/b*T2*T3-T1 #escriba aca la expresión
  return y

"""2. Construya un diccionario con las claves "X", "Y", "Tiempo"

3. Con el diccionario construya un data frame de pandas llamado df con los nombres de columnas "X", "Y", "Tiempo"  https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html. Defina 1000 regitros para el intervalo de tiempo elegido.


4. Realice un gráfico de x como función del tiempo, de y como función del tiempo y la trayectoria de la partícula (df["X"], df["tiempo"], df["Y"]).


5. Determine el alcance máximo de la partícula, para ello tome  la solucion teórica con $y=0$, solucione numéricamente la ecuación para t y remplace este valor en la ecuación para x. Resuelvalo para $\theta=45^{o}$.  

6. Construya una  grafica del alcance máximo R como función de $\theta$, varie $\theta$  entre 10 y 80 grados cada 5 grados.

"""

t=np.linspace(0,10,100)
data = {'Tiempo':np.linspace(0,10,100),"X":pos_x(t,theta,*Params),"Y": pos_y(t,theta,*Params)}
df= pd.DataFrame(data)

plt.plot(df["Tiempo"],df["X"])
plt.plot(df["Tiempo"],df["Y"])
plt.hlines(0,0,10,'k')

plt.plot(df["X"],df["Y"])
plt.hlines(0,0,250,'k')

pos_y(t, theta,*Params)
t0=6
f_raiz_N_R= optimize.newton(pos_y,t0, args=(theta,*Params),maxiter=100)
f_raiz_N_R #Tiempo de caida de la particula

R = pos_x(f_raiz_N_R, theta,*Params)
 R

theta= np.linspace(np.deg2rad(10),np.deg2rad(80),14)
R= [pos_x(f_raiz_N_R, theta,*Params) for theta in theta]

plt.plot(theta,R)