# -*- coding: utf-8 -*-
"""Copia de Lab03_Algoritmia_y_graficacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wSUCY65d2iiyji-ebTY5pIVZ2BtPmRVA

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab03_Algoritmia_y_graficacion.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

1.0 Caos numérico en un mapa logístico y errores de punto flotante (Errores de redondeo)

> Un ejemplo clásico de caos,  es el comportamiento no lineal en las interaciones de un mapa logístico 

\begin{equation}
x_{n+1}=f(x_n)=rx_n(1-x_n)
\end{equation}

> con $x\in (0,1)$ y $r\in(0,4)$ se pueden producir varios comportamientos sorprendentes.

Para este problema, será extremadamente útil  ver sus resultados gráficamente; construya listas de números y llame la libreria matplotlib. 


> ### Problema: 
1. Programar la ecuación para el mapa logístico, y  realizar una grafica del valor de xn como funcion de n.

2. Realizar pruebas para un $x_0=0.5$, con valores de r

```
  r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
  numpoints = 100, # Numero sugerido de iteraciones
  x0 = 0.5
```

Organizar las gráficas [multiples plot](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html)



3. Construye una rutina llamada logist_map en que entrada el valor de r, la condiciones inicial xi y el número de puntos determine la evolución en el punto N.  Prueba implementado las siguientes lineas.

```
Np = 1000
xf = np.zeros(Np)
r  = np.linspace(2.5, 4, Np)
 
for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r = r[i], xi = xini, N = 1000) 
  xf[i] = x_i
```


4. Realiza un gráfico de:
```
  plt.plot((r-1/r), xf,  ".", markersize = 0.5)
```


5. Encontrar dos formas adicionales de expresar $f(x)$, para estos valores funcionales determinar las mismas gráficas del numeral 3 para cada uno de las formas de escribir la expresión. En este caso se espera que los resultados varien. ¿A que se debe esto?. La respuesta no es inmediata, constulta algunas fuentes para sacar tu propia conclusión.

2.0 El algoritmo de gradiente descendente permite encontrar el minimo de funciones en espacios multidimensionales proponiendo puntos en la direccion en la que el gradiente desciende. Para el caso de una dimensión, podemos encontrar el mínimo realizando iteraciones y multiplicando su derivada en cada nuevo punto por una constante $\alpha$

\begin{equation}
x_{i+1}=x_i - \alpha \frac{\mathrm{d}f}{\mathrm{d}x}(x_i)
\end{equation}

Ejemplo:

Sea $f(\omega) = (\omega-1)^2$ , con $\omega \in \mathbb{R} $. El minimo de esta función esta determinado por
\begin{equation}
\frac{\mathrm{d}f}{\mathrm{d}\omega} = 0
\end{equation}

\begin{equation}
\omega = 1
\end{equation}


Para determinar el minimo,  a través del gradiente descendente puede ser aplicada el siguiente algoritmo:
1. Proponer un número aleatorios inicial $\omega_i$
2. Para descender al mínimo de la función, encontremos un  valor para el cual 
la derivada de la función descenciende, asi:
\begin{equation}
\omega_{i+1} = \omega_{i} - \alpha \frac{\mathrm{d}f(\omega_i)}{\mathrm{d}\omega}
\end{equation}

donde, $\alpha$ es conocido como la tasa de aprendizaje del algoritmo. 

3. Evaluar $f(\omega_{i+1})$

4. Iterar hasta encontrar el minimo de la función 


En el caso de la funcion propuesta, asumiendo un valor de $\alpha=1$, tenemos que:

1. Supongamos que $\omega_{0} = 2$, luego :
2. $\omega_{0+1} = 2 - 1 f'(\omega_{0}) =  = 0$
3. $f(0) = 1$
4. $\omega_{1+1} = 0 - 1 f'(\omega_{1}) = 0-1(2(0-1)) =  2$

El valor del $\omega$  despues de un par de iteraciones, no es el esperado, por que no minimiza la función, se debe proponer un tasa de aprendizaje  **$\alpha$** de tal forma que permita descender suavemente para encontrar el minimo. 



**Su tarea será**:

1. Disenar un programa, en el que entrada la función y su derivada, definidas como funciones lambda de python, se determine el valor mínimo de esa función. 
Prueba tu algoritmo para  la función $f(x) = x^2$

2. Realiza el grafico de la funcion y la derivada, especifica la leyenda de cada curva empleando el metodo legend() de matplotlib.
  

3. Analiza como se minimiza la función, gráficando de la funcion en cada punto a iterar,  como funcion del numero de iteraciones. Para dos valores diferentes de la constante alpha (prueba con $\alpha=0.1$, $\alpha=0.01$)

# **Problema1**
"""

import numpy as np
import matplotlib.pyplot as plt

x0=0.1
r= 3.8
X=np.zeros(100)
X[0]=x0


for i in range(1,100):
  X[i]= r*X[i-1]*(1-X[i-1])
y= np.linspace(0, 100, 100)
plt.figure(figsize=(5,5))
plt.title("Mapa logistico para $r=3.8$")
plt.xlabel("$x$",fontsize=14)# esto es para cambiar el tamaño y rotular los ejes
plt.ylabel("$y$", fontsize=14)
plt.plot(y,X)

"""# **Problema 2**"""

def mapa_logistico(x,r,n):
  result= []
  for ri in r:
    X=np.zeros(n)
    X[0]=x
    for i in range(1,n):
      X[i]= ri*X[i-1]*(1-X[i-1])

    result.append(X)

  return np.array(result)


x0= 0.5
r= np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
n= 100
y= np.linspace(0,n,n)
a=mapa_logistico(x0,r,n)
colors= ['blue','orange','green','red','purple','brown']

fig, axs = plt.subplots(len(r), figsize=(15,2.5*len(r)))
fig.suptitle('Mapas logisticos para diferentes valores de r')
for i in range(0,len(r)):
  axs[i].plot(y, a[i],'tab:'+colors[i])
  axs[i].set_title('Para $r$= '+ str(r[i]))

"""# **Problema 3**"""

def logist_map(r,x0,N):
  xf = np.zeros(N)
  xf[0]= x0
  for i in range(1,N):
    xf[i]= r[i-1]*xf[i-1]*(1-xf[i-1])
   
  return xf  

Np=1000
r  = np.linspace(2.5, 4, Np)
xo= np.random.rand()
arra_final= np.zeros(Np)

for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r, xini, Np) 
  arra_final = x_i


plt.figure(figsize=(10,0.004*len(r)))
plt.plot(r,arra_final)
plt.xlabel("$r$",fontsize=14)
plt.ylabel("Logistic_map",fontsize=14)
plt.title("Mapa logistico")

#logist_map(r,xo,Np)

"""# **Problema 4**"""

plt.figure(figsize=(10,0.004*len(r)))
plt.plot((r-1/r), arra_final,  ".", markersize = 1)
plt.xlabel("$r$",fontsize=14)
plt.ylabel("Logistic_map",fontsize=14)
plt.title("Mapa logistico")

"""# **Tarea**

## Gradiente descendente
"""

def grad_des(alpha,iteraciones):
#alpha = 0.1
#iteraciones= 50
  funcion= lambda x: x**2
  derivada= lambda x:2*x
  valores= np.zeros(iteraciones)
  x0= np.random.randint(iteraciones)
  valores[0]= x0
#print(valores)
  for i in range(1,iteraciones):
    valores[i]= valores[i-1] -alpha*derivada(valores[i-1])
  #print(funcion(valores[i]))

  return valores[-1] 
  #print(x0)
grad_des(0.1,50)

def grad_des(alpha,iteraciones):

  funcion= lambda x: x**2
  derivada= lambda x:2*x
  valores= np.zeros(iteraciones)
  x0= np.random.randint(iteraciones)
  valores[0]= x0

  for i in range(1,iteraciones):
    valores[i]= valores[i-1] -alpha*derivada(valores[i-1])
  return valores


min1= grad_des(0.01,100)
min2= grad_des(0.1,100)
f=lambda x: x**2
df= lambda x: 2*x
x= np.linspace(0,10,100)

plt.figure(figsize=(10,10))
plt.plot(x,f(x),label="Funcion")
plt.plot(x,df(x),label= "Derivada")
plt.plot(x,min1,"yo",markersize = 2, label="Gradiente alpha=0.01")
plt.plot(x,min2,"ro",markersize = 2, label="Gradiente alpha=0.1")
plt.title("Algoritmo del Gradiente descendente")
plt.legend()