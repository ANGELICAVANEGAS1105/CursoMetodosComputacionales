# -*- coding: utf-8 -*-
"""Copia de Lab05_errores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sn8zDmJ0Xau2hUW42Jn78Opwq_-gRjGO

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab05_errores.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

## Exponencial, serie alternante (serieEn)
Objetivo: Analizar el uso de la cancelación substractiva


Copia textual del libro  [Computational Physics. ](https://www.dropbox.com/s/n06ul2r4l65khl6/Computational%20Physics%20-%20Problem%20Solving%20with%20Computers%2C%203527406263.pdf?dl=0)

- Write a program that calculates $e^{-x}$ 

\begin{equation}
e^{-x}=\sum_{n=0}^{N}  (-1)^n \frac{x^{n}}{n!}
\end{equation}


- Calculate your series for $x \le 1$ and compare it to the built-in function
exp(x) (you may assume that the built-in exponential function is exact).
You should pick an N for which the next term in the series is no more
than $10^{-7}$ of the sum up to that point

\begin{equation}
\left| \frac{(-x)^{N+1}}{(N+1)!} \right | \le \left| 10^{-7} \sum_{N=0}^{N} \frac{(-x)^{n}}{n!} \right|
\end{equation}

- Examine the terms in the series for $x\approx 10$ and observe the significant subtractive cancellations that occur when large terms add together to give small answers. In particular, print out the near-perfect cancellation
at $n \approx x − 1$.

- See if better precision is obtained by being clever and using exp(−x) = 1/ exp(x) for large x values. This eliminates subtractive cancellation, but does not eliminate all roundoff errors

- By progressively increasing x from 1 to 10, and then from 10 to 100, use your program to determine experimentally when the series starts to lose accuracy, and when the series no longer converges

- Make a series of graphs of the error versus N for different values of x.


## Cancelación sustractiva



**serieSn**. Un ejemplo de la cancelacion substractiva es en la suma de series alternantes. Considere la serie $\mathrm{S}_N$,  escrita  matematicamente de tres formas diferentes:

- 
\begin{equation}
\mathrm{S}_N^{(1)} = \sum_{n = 1}^{2N} (-1)^n \frac{n}{n+1} 
\end{equation}

- Sumando números pares e impares.

\begin{equation}
\mathrm{S}_N^{(2)} = -\sum_{n = 1}^{N}\frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1}
\end{equation}

- Combinando las series de una forma analítica

\begin{equation}
\mathrm{S}_N^{(3)} = \sum_{n = 1}^{N}\frac{1}{2n(2n+1)}
\end{equation}



Las tres sumas $\mathrm{S}_N^{(1)}$, $\mathrm{S}_N^{(2)}$ y $\mathrm{S}_N^{(3)}$ son matemáticamente iguales, pero los resultados  pueden tener resultados numéricos diferentes.


- Escribir un programa que realice el cálculo de $\mathrm{S}_N^{(1)}$, $\mathrm{S}_N^{(2)}$ y $\mathrm{S}_N^{(3)}$
- Estudiar la convergencia de la serie para los tres casos.
- Considere  que $S_N^{(3)}$ es la solución exacta, realizar dos graficos log-log, del error relativo en función 
del número de términos ($\mathrm{Log_{10}} E$ VS $\mathrm{Log_{10}} N$), para $S_N^{(1)}$ y $S_N^{(2)}$. Donde,  $E = |(S_N^{(i)} - S_N^{(3)})/S_N^{(3)}|$, i = 1, 2. Considere valores de $N = 1\times 10^{6}$.
- Analizar y discutir los resultados. Tenga en cuenta la discusión realizada sobre teoría de errores en la página 
39 del libro del libro [Computational Physics. ](https://www.dropbox.com/s/n06ul2r4l65khl6/Computational%20Physics%20-%20Problem%20Solving%20with%20Computers%2C%203527406263.pdf?dl=0)
"""

import matplotlib.pyplot as plt
import numpy as np
def expo(x,N): # esta funcion acepta un numero para x y otro para N que es el numero de sumas que se hacen dentro de la sumatoria
  
  n= np.arange(0,N).astype(int) #Genera un vector con el numero de potencias que se van a usar en la serie en funcion de N
  S= ((-1)**n)# Genero el vector que alterna los signos
  pot_x= x**n # saco las potencias para los diferentes n
  fac_= []#Genero una lista vacia
  for i in range(0,len(n)): #Saco el factorial para cada numero entre cero y el numero de n
    fact= np.math.factorial(i)
    fac_.append(fact)# agrego el resultado a la lista vacia

  v_arra = np.array(fac_) #lo transformo en un vector
  suma = ((S*pot_x)/(v_arra)).sum() #hago la sumatoria
  return suma

expo(2,13)

e= np.exp(-2)
e

def presi_exp(x): # esta funcion saca los valores de N para los cuales la presicion es de almenos 1E(-7) comparada con la funcion np.exp(x)
  N=0
  while True: # estra al ciclo

    A= abs((-x)**N+1)/abs(np.math.factorial(N+1))# a la variable A se le cuarda la operacion de la formula
    B= abs((10**-7)*expo(x,N)) # a la variable B guarda el producto de mi funcion por el error sugerido
    if A <= B:# hago la desigualdad si se cumple rompe el siclo
      break
    else:  #sino entonces a lo que hay en N sumarle 1
      N += 1
  return N
   
presi_exp(-2)

print(expo(3,23)) # se calcula con la serie y con la funcion de numpy la misma exponencial y se muestra
a= np.exp(-3)
a
error= expo(3,15)-np.exp(-3)
error

x= np.linspace(0,10,100)
lista = [expo(i,presi_exp(i))for i in x ]
lista

x= np.linspace(0,39,100) # A medida que voy metiendo numeros grandes para obtener numeros pequeños comienza a diverger.
plt.plot(x,np.exp(-x),"o",label= "Exponencial")# Diverge para x cercanos a 39
plt.plot(x,[expo(i,presi_exp(i))for i in x ],"--",label= "Serie")
plt.legend()

x= 9.99 #Pero para valores con las condiciones puestas en el ejercicio las cosas cambian
n= x-1
expo(x,n)

b= 1/np.exp(x) # se obtienen valores diferentes 
b

diff= b-expo(x,n) # el numero de sumas debe ser mayor para acercarnos un poco al valor deseado
diff

n= presi_exp(x) #vemos que usando el codigo del error se aproxima más al valor deseado
expo(x,n)

diff= expo(x,n)-b # El error se reduce sustancialmente
diff

x= np.linspace(0,39,100)
Ns=[presi_exp(i)for i in x] # N necesarios para 100 valores de x en el intervalo(0,39)
N_vector= np.array(Ns)        #la lista en array
npexp= [np.exp(-i) for i in x]   #saco la lista de los diferentes valores de x evaluados en el mismo intervalo
serien=[expo(i,presi_exp(i)) for i in x] # evaluo los mismos valores para la serie
error = (np.array(serien)-np.array(npexp))/ np.array(np.array(npexp))  #convierto las listas en arrays y los resto para saber la difernecia
# Grafico
plt.figure(figsize=(10,5))
plt.plot(N_vector,error,"o")
plt.title("Grafica de N vs error")
plt.xlabel("N")
plt.ylabel("Error")

"""## Cancelación sustractiva



**serieSn**. Un ejemplo de la cancelacion substractiva es en la suma de series alternantes. Considere la serie $\mathrm{S}_N$,  escrita  matematicamente de tres formas diferentes:

- 
\begin{equation}
\mathrm{S}_N^{(1)} = \sum_{n = 1}^{2N} (-1)^n \frac{n}{n+1} 
\end{equation}

- Sumando números pares e impares.

\begin{equation}
\mathrm{S}_N^{(2)} = -\sum_{n = 1}^{N}\frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1}
\end{equation}

- Combinando las series de una forma analítica

\begin{equation}
\mathrm{S}_N^{(3)} = \sum_{n = 1}^{N}\frac{1}{2n(2n+1)}
\end{equation}



Las tres sumas $\mathrm{S}_N^{(1)}$, $\mathrm{S}_N^{(2)}$ y $\mathrm{S}_N^{(3)}$ son matemáticamente iguales, pero los resultados  pueden tener resultados numéricos diferentes.


- Escribir un programa que realice el cálculo de $\mathrm{S}_N^{(1)}$, $\mathrm{S}_N^{(2)}$ y $\mathrm{S}_N^{(3)}$
- Estudiar la convergencia de la serie para los tres casos.
- Considere  que $S_N^{(3)}$ es la solución exacta, realizar dos graficos log-log, del error relativo en función 
del número de términos ($\mathrm{Log_{10}} E$ VS $\mathrm{Log_{10}} N$), para $S_N^{(1)}$ y $S_N^{(2)}$. Donde,  $E = |(S_N^{(i)} - S_N^{(3)})/S_N^{(3)}|$, i = 1, 2. Considere valores de $N = 1\times 10^{6}$.
- Analizar y discutir los resultados. Tenga en cuenta la discusión realizada sobre teoría de errores en la página 
39 del libro del libro [Computational Physics. ](https://www.dropbox.com/s/n06ul2r4l65khl6/Computational%20Physics%20-%20Problem%20Solving%20with%20Computers%2C%203527406263.pdf?dl=0)
"""

def serie1(N):
  n= np.arange(1,2*N+1)
  S1= ((((-1)**n)*n)/(n+1)).sum()
  return S1
serie1(100000)

def serie2(N):
  n=np.arange(1,N+1)
  A= (-1)*((((2*n)-1)/(2*n)).sum())
  B= ((2*n)/((2*n)+1)).sum()
  S2= A+B
  return S2
serie2(100000)

def serie3(N):
  n= np.arange(1,N+1)

  serie3=(1/((2*n)*((2*n)+1))).sum()

  return serie3

serie3(100000)

def Error1(N):
  Error= (serie1(N)-serie3(N))/(serie3(N))
  return Error

def Error2(N):
  Error= (serie2(N)-serie3(N))/(serie3(N))
  return Error

N= np.logspace(1,6,100)
y1 = [Error1(i)for i in N]
y1_= np.array(y1)
y1_abs= np.abs(y1_)


fig, ax = plt.subplots()
ax.loglog(N, y1_abs,'o')
ax.set_xlabel('N')
ax.set_ylabel('Error')
plt.show()

N= np.logspace(1,6,100)
y2 = [Error2(i)for i in N]
y2_= np.array(y2)
y2_abs= np.abs(y2_)
#y2_abs

fig, ax = plt.subplots()
ax.loglog(N, y2_abs,'o')
ax.set_xlabel('N')
ax.set_ylabel('Error')
plt.show()