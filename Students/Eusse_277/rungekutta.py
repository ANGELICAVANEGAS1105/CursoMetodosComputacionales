# -*- coding: utf-8 -*-
"""RungeKutta.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16aeZBc8O9BeOKMkSNv-SZTjm_88zzDwM
"""

import numpy as np
import matplotlib.pyplot as plt

def funtion(t,y,params):
  a= params[0]
  dydt= -a*y
  return dydt

t0= 0.0
y0= 100
a= 1 
params= (a,)

t0= 0
tfin= 1
Nt= 100
h= 1/Nt
t= np.linspace(t0, tfin, Nt)


k1= funtion(t0,y0, params)
k2 = funtion(t0+h/2, y0+h/2*k1, params)
k3=  funtion(t0+h/2, y0+h/2*k2, params)
k4= funtion(t0+h/2,y0+h/2*k3, params)
kmean = 1/6*(k1+2*k2+2*k3+k4)

y1= y0 +kmean*h

t1= t0+h
k1= funtion(t1,y1, params)
k2 = funtion(t1+h/2, y1+h/2*k1, params)
k3=  funtion(t1+h/2, y1+h/2*k2, params)
k4= funtion(t1+h/2,y1+h/2*k3, params)
kmean = 1/6*(k1+2*k2+2*k3+k4)

y2= y1 + kmean*h

Y= np.zeros(Nt+1)
Y[0]= y0
T = np.linspace(0,1,Nt+1)
h= 1/Nt
t0= 0.0
y0= 100
a= 1 
params= (a,)

T

#range?

for i in range(0, Nt): 
  k1= funtion(T[i], Y[i], params)
  k2 = funtion(T[i]+h/2, Y[i]+h/2*k1, params)
  k3=  funtion(T[i]+h/2, Y[i]+h/2*k2, params)
  k4= funtion(T[i]+h/2,Y[i]+h/2*k3, params)
  kmean = 1/6*(k1+2*k2+2*k3+k4)
  Y[i+1] = Y[i]+kmean*h

print(len(Y))

print(len(T))

plt.plot(T,Y)
plt.title("Runge_Kutta")
plt.xlabel("Tiempo")
plt.ylabel("$y$")

def f(t,x,y,params): # Tener en cuenta que RungeKutta solo aplica a la ecuacion que se esta analizando
  a= params[0]
  dxdt= a*(y-x)
  return dxdt

def g(t,x,y,z,params):
  b= params[1]
  dydt= x(b-z)-y
  return dydt 

def h(t,x,y,z,params):
  c= params[2]
  dzdt= x*y -c*z
  return dzdt

sigma = 10
rho = 97
beta = 8./3
posI = [1, 1, 1]
N = 1000
ti = 0
tfin = 40


params=(sigma, rho, beta )
dt = h = 0.001
t = np.arange(0, 40, dt)
ti=t[0]
N=len(t)
x = np.zeros(N)
y = np.zeros(N)
z = np.zeros(N)
x[0], y[0],z[0] = np.array(posI)  



def fun(t, x,y,z, params):
  sigma = params[0]  
  rho = params[1]  
  beta = params[2]   

  dxdt = sigma*(y-x)
  dydt = x*(rho-z)-y
  dzdt = x*y-beta*z
  return np.array([dxdt, dydt, dzdt])



for i in range(0, N-1):
  k1 = fun(ti,       x[i],            y[i], z[i], params)[0]
  k2 = fun(ti + h/2, x[i] + h/2 * k1, y[i], z[i], params)[0]
  k3 = fun(ti + h/2, x[i] + h/2 * k2, y[i], z[i], params)[0]
  k4 = fun(ti + h  , x[i] + h   * k3, y[i], z[i], params)[0]
  kmean = (1/6) * (k1 + 2*k2 + 2*k3 + k4)   
  x[i+1] = x[i] + kmean*h
  
  q1 = fun(ti,       x[i],  y[i]           , z[i], params)[1]
  q2 = fun(ti + h/2, x[i],  y[i] + h/2 * q1, z[i], params)[1]
  q3 = fun(ti + h/2, x[i],  y[i] + h/2 * q2, z[i], params)[1]
  q4 = fun(ti + h  , x[i],  y[i] + h   * q3, z[i], params)[1]
  qmean = (1/6) * (q1 + 2*q2 + 2*q3 + q4)   
  y[i+1] = y[i] + qmean*h
  

  c1 = fun(ti,       x[i],  y[i], z[i], params)[2]
  c2 = fun(ti + h/2, x[i],  y[i], z[i] + h/2 * c1, params)[2]
  c3 = fun(ti + h/2, x[i],  y[i], z[i] + h/2 * c2, params)[2]
  c4 = fun(ti + h  , x[i],  y[i], z[i] + h   * c3, params)[2]
  cmean = (1/6) * (c1 + 2*c2 + 2*c3 + c4)   
  z[i+1] = z[i] + cmean*h

  ti=ti+dt

fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.plot(x, y, z)
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("z")
plt.show()