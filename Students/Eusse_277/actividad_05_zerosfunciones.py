# -*- coding: utf-8 -*-
"""Actividad_05_ZerosFunciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/136uBKlsaUzub68W6nsrOBMSCCa_LQZDK

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Actividades_clase/Actividad_05_ZerosFunciones.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>



# Actividad 5
### Métodos computacionales para físicos  y astrónomos
### Universidad de Antioquia
### Prof: Hernan D. Salinas Jiménez
Ref: https://github.com/restrepo/ComputationalMethods

In an IPython notebook, use the scipy implementation and find the first solution to the equation, write a function with the bisection methods.

What is the solution if a=1, and b=1, what is the solution if a=2 and b=2
  
1. $ 7 = a\sqrt{x^2+1}+be^x\sin x $

2. $a e^{x}-2= b\cos(e^x-2)$

3. Fixed point methods. 

When a new planet is discovered, there are different methods to estimate its physical properties. Many times is only possible to estimate either the planet mass or the planet radius and the other property has to be predicted through computer modelling.

If one has the planet mass, a very rough way to estimate its radius is to assume certain composition (mean density) and a homogeneous distribution (a very bad assumption!). For example, for the planet [Gliese 832c](http://es.wikipedia.org/wiki/Gliese_832_c) with a mass $M= 5.40 M_{\oplus}$, if we assume an earth-like composition, i.e. $\bar \rho_{\oplus} = 5520\ kg/m^3$, we obtain:

$$R_{g832c} = \left( \frac{3 M_{g832c}}{ 4 \pi \bar\rho_{\oplus} } \right)^{1/3} \approx 1.75 R_{\oplus}$$

That would be the planet radius if the composition where exactly equal to earth's.

A more realistic approach is assuming an internal one-layer density profile like:

$$\rho(r) = \rho_0 \exp\left( -\frac{r}{L} \right)$$

where $\rho_0$ is the density at planet centre and $L$ is a characteristic lenght depending on the composition. From numerical models of planet interiors, the estimated parameters for a planet of are $M= 5.40 M_{\oplus}$ are approximately $\rho_0 = 18000\ kg/m^3$ and $L = 6500\ km$.

Integrating over the planet volume, we obtain the total mass as

$$M = 4\pi \int_0^R \rho(r)r^2dr$$

This is a function of the mass in terms of the planet radius. 

Solving the equation $M(R) = M_{g832c}$ it would be possible to find a more realistic planet radius. However when using numerical models, it is not possible to approach the solution from the left side as a negative mass makes no sense.

3. **ACTIVITY** 
    
In an IPython notebook and based on the routine NewtonRaphson, write your own routine SecantMethod that performs the previous steps for the Secant Method. Test your code with the function $f(x)$:
    
$f(x) = x - \cos(x)$
</font>

4. **ACTIVITY** 


It is known that light rays are deflected when they pass near by a gravitational field and that this deviation is proportional to the body mass which the light is interacting with and inversely proportional to the passing distance. 
Since it is common finding very massive structures in the universe and the measures that are done to study it involve photons, it makes sense to study what happens to a light source image when the rays get close to a grumpy object like a dark matter halo.  


In order to study the light deflection in these cases, it will be used the simplest model, gravitational lens theory, where the len is a very massive object. A sketch of a typical system is shown in the figure below. The source plane is the light source or image that is going to be affected,  $\eta$ is the distance from a image point to the line of sight and $\beta$ the subtended angle by the point. 
The lens plane corresponds to the mass that affects the light coming from the source, $\xi$ is the new image point distance to the line of sight, $\theta$ is the subtended angle by the new point position. Then, $\alpha$ is the deflection angle. 

Since from observations $\theta$ is known, the problem to be solved per pixel usually is 

\begin{equation}
\beta = \theta - \hat{\alpha}(\theta) 
\end{equation}

but $\alpha$ also depends on $\theta$ besides the len halo properties. This would allow construct the real image
from the distorted and magnified one. 

<img src="https://github.com/restrepo/ComputationalMethods/blob/master/material/figures/lente1.png?raw=1">

This equation can also be written in terms of distances 

\begin{equation}
\vec{\eta}  = \frac{D_s}{D_d} \vec{\xi} - D_{ds}\alpha ( \vec{\xi }) 
\end{equation}

The solution to the lens equation is easier to get if it is assumed that the len is axially symmetric. In this case, the deflection angle  takes the next form

$$ \hat{\alpha}(\vec{\xi}) = \frac{\vec{\xi}}{|\vec{\xi}|^2} \frac{8G\pi}{c^2} \int_0^\xi d\xi'\xi'\Sigma(\xi')$$

The quantity $\Sigma$ is the surface mass density, i.e., the len's mass enclosed inside $\xi$ circle per area unit.  
It is important to notice that the direction of $\alpha$ is the same as $\xi$ and consequently $\eta$. 


The problem to be solved is the next: Given the positions of a square find the image distorsion due to gravitational lensing, i.e., find the root of \xi in the trascendal equation it satisfies. Use the routines given below and all of 
the data for the len and image that is going to be distorted.

# **Actividad 1**

In an IPython notebook, use the scipy implementation and find the first solution to the equation, write a function with the bisection methods.

What is the solution if a=1, and b=1, what is the solution if a=2 and b=2
  
1. $ 7 = a\sqrt{x^2+1}+be^x\sin x $

2. $a e^{x}-2= b\cos(e^x-2)$
"""

from scipy import linalg, optimize
import numpy as np
import matplotlib.pyplot as plt

def f(x):
  a= 1
  b= 1
  T1=a*(np.sqrt((x**2)+1))
  T2=b*((np.exp(x))*(np.sin(x)))

  return T1+ T2 - 7


x= np.linspace(0,10,100)
x
f(x)
plt.figure(figsize=(5,5))
plt.plot(x,f(x))
plt.xlim(4.5,6.5)
plt.grid()

from scipy import optimize

root = optimize.bisect(f, 4, 8)
root

raiz= optimize.bisect(f,4.5,6.5)
print(f(raiz))

def f(x):
  return 2*(np.sqrt((x**2)+1))+ 2*((np.exp(x))*(np.sin(x))) - 7

raiz= optimize.bisect(f,9,10)
print(raiz)

f(raiz)

def g(x):
  a=2
  b=2
  return b*np.cos(np.exp(x)-2)-a*np.exp(x)+2

x= np.linspace(0,2,1000)

plt.figure(figsize=(5,5))
plt.plot(x,g(x))
plt.hlines(0,0,2,'k')
plt.grid()

g(x)

raiz= optimize.bisect(g,0,5)
print(raiz)

plt.figure(figsize=(5,5))
plt.plot(x,g(x))
plt.hlines(0,0,2,'k')
plt.plot(raiz,g(raiz),'ro')
plt.grid()

def g(x):
  a=2
  b=2
  return b*np.cos(np.exp(x)-2)-a*np.exp(x)+2

raiz= optimize.bisect(g,0,5)
print(g(raiz))

"""# **Actividad 3**

3. **ACTIVITY** 
    
In an IPython notebook and based on the routine NewtonRaphson, write your own routine SecantMethod that performs the previous steps for the Secant Method. Test your code with the function $f(x)$:
    
$f(x) = x - \cos(x)$
</font>
"""

def f2(x):
  return x- np.cos(x)

ejex = np.linspace(0,10,100)

plt.figure(figsize=(5,5))
#plt.xlim(0,2.0)# con una aproximacion a la grafica sé que la raiz debe de estar cerca de 0.75
plt.plot(ejex,f2(ejex))
plt.grid()

def Df(x): #La derivada de la funcion f2
  return 1 + np.sin(x)

plt.figure(figsize=(5,5))
plt.plot(ejex,Df(ejex))
plt.grid()

x0=0
def Newton_raphson(x0): #Metodo de Newton _raphson

  x_n= np.zeros(10)
  i=1
  x_n[0]= x0
  while True: 
    x_n[i]= x_n[i-1]-(f2(x_n[i-1])/Df(x_n[i-1])) 
    if round(x_n[i],5) == round(x_n[i-1],5):
      break
    else:
      i += 1
  return x_n[i]

Newton_raphson(x0)  
f2(Newton_raphson(x0))

def method_secan(x0,x1): # este es el Metodo de la secante
  x_n2= np.zeros(10)
  x_n2[0]=x0
  x_n2[1]= x1
  i=3
  
  while True:
    
    x_n2[i-1]= x_n2[i-2]-((x_n2[i-2]-x_n2[i-3])/(f2(x_n2[i-2])-f2(x_n2[i-3])))*f2(x_n2[i-2])

    if round(x_n2[i-1],5) == round(x_n2[i-2],5):
        break
    else:
        i += 1
  return x_n2[i-1]



f2(method_secan(0,0.5))

"""# **Actividad 4**"""

import sympy as sp #Aquì usamos sympy para usar el calculo simbolico

x = sp.symbols("x")

def f(x):
  T1= sp.sqrt(x**2+1)
  T2= sp.exp(x)*sp.sin(x)
  return T1+T2-7

def fp(x):
  T1= x*(sp.sqrt(x**2+1))
  T2= sp.exp(x)*sp.sin(x)
  T3= sp.exp(x)*sp.cos(x)
  return T1+T2+T3

sp.diff(f(x),x)

fun=sp.lambdify(x,f(x),"numpy")
Df_= sp.lambdify(x,fp(x),"numpy")

fun(2)

def h(x):            #Metodo de punto fijo
  return x-fun(x)

x0=1

root= optimize.fixed_point(h,x0)
fun(root)

