# -*- coding: utf-8 -*-
"""Ecuaciones_Diff.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mViOS8FulOH0ltKHo2U5MZtj9atC3Chx

## **Actividad 01**

Resolver la siguiente ecuacion difirencial, empleando el metodo de Euler, para ello debera consultar en una inteligencia artificial el metodo de Euler, también deberá generar el código en markdown con la explicación del método y las deducciones.

\begin{equation}
\frac{dN}{dt}= 	-\lambda N
\end{equation}

## **Soluciòn**

La fórmula de iteración del método de Euler es:
\begin{equation}
y_{i+1} ≈ y_i + h * f(x_i, y_i)
\end{equation}  

donde $y_i $es la aproximación de la función y en el punto $x_i$, h es el tamaño del paso, $f(x_i, y_i)$ es la función que determina la pendiente de la curva en el punto $(x_i, y_i)$, y $y_{i+1}$ es la aproximación de la función y en el punto $x_{i+1}$.

Esta fórmula nos permite calcular sucesivamente los valores de y en diferentes puntos a medida que avanzamos en el dominio de interés.

Recuerda que esta es una aproximación de primer orden, por lo que la precisión aumenta linealmente con el tamaño del paso h. Para obtener una mayor precisión, se requieren pasos más pequeños.
"""

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt

lam= 5

funtion= lambda t,N: -lam*N
# Condicion inicial
#tiempo 0

N_0= 100
Deltat= 0.1

#Tiempo 1

N_1= N_0+ Deltat*funtion(Deltat, N_0)

a= 0
b=1
lamb= 10
Npoints= 100
Ni=200
t= np.linspace(a,b,Npoints)
dt= (b-a)/Npoints
N= np.zeros(Npoints)
N[0]= Ni
funtion= lambda t,N: -lamb*N

for i in range(0,len(t)-1):
  N[i+1] = N[i] + funtion(dt,N[i])*dt

plt.plot(t,N)

"""# Actividad 02  

  
1. Oscilador armónico:
Resolver la siguiente ecuacion difirencial, empleando el metodo de Euler.

\begin{equation}
m\frac{d^{2}x}{dt^{2}} + kx +bv= 	0
\end{equation}  

3. Construir un codigo en python a traves de la IA, realizando preguntas adeacuadoas para para dar la solución la ecuación diferencial, compare los resultados.
"""

def oscilador(y0,v0,m,b,k,dt,num,tiempo):
  w= np.sqrt(k/m)
  Y = np.zeros(num) #Valores en ceros para el numero de puntos
  V = np.zeros(num)
  Y[0]= y0
  V[0]= v0
  t = np.linspace(0,tiempo,num)
  for i in range(0, len(t)-1):
   Y[i+1]= Y[i] + V[i]*dt
   V[i+1]= V[i]-(w**2)*Y[i+1]*dt-b*V[i]
  return Y,V

y0=0.001
v0=0
m=4
b=0.01
k=2
dt=0.1
num=1000
tiempo=100

oscilador(y0,v0,m,b,k,dt,num,tiempo)[0]
oscilador(y0,v0,m,b,k,dt,num,tiempo)[1]

plt.plot(oscilador(y0,v0,m,b,k,dt,num,tiempo)[0],label="Posicion")
plt.plot(oscilador(y0,v0,m,b,k,dt,num,tiempo)[1],label="Velocidad")
plt.legend()