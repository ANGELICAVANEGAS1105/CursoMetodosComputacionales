# -*- coding: utf-8 -*-
"""Lab03_Algoritmia_y_graficacion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17cwdgGr9lZonVYklv80V9Rb36Q69sgvE

>>>[Problema:](#scrollTo=SkZguDaDeyAZ&uniqifier=1)

>[Trabajo en clase](#scrollTo=WZnPyBmDu50j&uniqifier=1)

>[Solución del laboratorio](#scrollTo=E7HtzyCM5j2a&uniqifier=1)

>>[Primera parte](#scrollTo=-ZNGmwBbCD68&uniqifier=1)

>>[Segunda parte](#scrollTo=7--xb7WJCKV1&uniqifier=1)

1.0 Caos numérico en un mapa logístico y errores de punto flotante (Errores de redondeo)

> Un ejemplo clásico de caos,  es el comportamiento no lineal en las interaciones de un mapa logístico 

\begin{equation}
x_{n+1}=f(x_n)=rx_n(1-x_n)
\end{equation}

> con $x\in (0,1)$ y $r\in(0,4)$ se pueden producir varios comportamientos sorprendentes.

Para este problema, será extremadamente útil  ver sus resultados gráficamente; construya listas de números y llame la libreria matplotlib. 


> ### Problema: 
1. Programar la ecuación para el mapa logístico, y  realizar una grafica del valor de xn como funcion de n.

2. Realizar pruebas para un $x_0=0.5$, con valores de r

```
  r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
  numpoints = 100, # Numero sugerido de iteraciones
  x0 = 0.5
```

Organizar las gráficas [multiples plot](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html)



3. Construye una rutina llamada logist_map en que entrada el valor de r, la condiciones inicial xi y el número de puntos determine la evolución en el punto N.  Prueba implementado las siguientes lineas.

```
Np = 1000
xf = np.zeros(Np)
r  = np.linspace(2.5, 4, Np)
 
for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r = r[i], xi = xini, N = 1000) 
  xf[i] = x_i
```


4. Realiza un gráfico de:
```
  plt.plot((r-1/r), xf,  ".", markersize = 0.5)
```


5. Encontrar dos formas adicionales de expresar $f(x)$, para estos valores funcionales determinar las mismas gráficas del numeral 3 para cada uno de las formas de escribir la expresión. En este caso se espera que los resultados varien. ¿A que se debe esto?. La respuesta no es inmediata, constulta algunas fuentes para sacar tu propia conclusión.

2.0 El algoritmo de gradiente descendente permite encontrar el minimo de funciones en espacios multidimensionales proponiendo puntos en la direccion en la que el gradiente desciende. Para el caso de una dimensión, podemos encontrar el mínimo realizando iteraciones y multiplicando su derivada en cada nuevo punto por una constante $\alpha$

\begin{equation}
x_{i+1}=x_i - \alpha \frac{\mathrm{d}f}{\mathrm{d}x}(x_i)
\end{equation}

Ejemplo:

Sea $f(\omega) = (\omega-1)^2$ , con $\omega \in \mathbb{R} $. El minimo de esta función esta determinado por
\begin{equation}
\frac{\mathrm{d}f}{\mathrm{d}\omega} = 0
\end{equation}

\begin{equation}
\omega = 1
\end{equation}


Para determinar el minimo,  a través del gradiente descendente puede ser aplicada el siguiente algoritmo:
1. Proponer un número aleatorios inicial $\omega_i$
2. Para descender al mínimo de la función, encontremos un  valor para el cual 
la derivada de la función descenciende, asi:
\begin{equation}
\omega_{i+1} = \omega_{i} - \alpha \frac{\mathrm{d}f(\omega_i)}{\mathrm{d}\omega}
\end{equation}

donde, $\alpha$ es conocido como la tasa de aprendizaje del algoritmo. 

3. Evaluar $f(\omega_{i+1})$

4. Iterar hasta encontrar el minimo de la función 


En el caso de la funcion propuesta, asumiendo un valor de $\alpha=1$, tenemos que:

1. Supongamos que $\omega_{0} = 2$, luego :
2. $\omega_{0+1} = 2 - 1 f'(\omega_{0}) =  = 0$
3. $f(0) = 1$
4. $\omega_{1+1} = 0 - 1 f'(\omega_{1}) = 0-1(2(0-1)) =  2$

El valor del $\omega$  despues de un par de iteraciones, no es el esperado, por que no minimiza la función, se debe proponer un tasa de aprendizaje  **$\alpha$** de tal forma que permita descender suavemente para encontrar el minimo. 



**Su tarea será**:

1. Disenar un programa, en el que entrada la función y su derivada, definidas como funciones lambda de python, se determine el valor mínimo de esa función. 
Prueba tu algoritmo para  la función $f(x) = x^2$

2. Realiza el grafico de la funcion y la derivada, especifica la leyenda de cada curva empleando el metodo legend() de matplotlib.
  

3. Analiza como se minimiza la función, gráficando de la funcion en cada punto a iterar,  como funcion del numero de iteraciones. Para dos valores diferentes de la constante alpha (prueba con $\alpha=0.1$, $\alpha=0.01$)

#Trabajo en clase
"""

import numpy as np
import matplotlib.pyplot as plt

x= np.linspace(0, 2*np.pi, 50)   #50 puntos de valores entre 0 y  2pi
f = lambda x: x**2 * np.sin(x) + (np.cos(x))**3

plt.plot(x,f(x))

#plt.plot?    #bajo para recibir la información acerca de elementos de la graficación

#lo graficamos de una mejor manera

plt.figure(figsize=(4,4))  #modificamos el tamaño de la figura

plt.plot(x,f(x),'bo-',  label='$x^2\sin(x)+\cos^3 x$')

plt.xlabel('$x$',fontsize= 14)        #cambia el tamaño de la letra
plt.ylabel('$f(x)$', fontsize= 14)       #defino el nombre de los ejes y pongo el signo pesos para que la ecuación salga como en formato de latex

plt.xticks(fontsize=14)       #cambio el tamaño de la letra de los ticks
plt.yticks(fontsize=14)

#plt.grid()

plt.title('f(x) vs x')
plt.legend(loc=3)   #pogo el loc para poner la posición en la que quiero ubicar el label

v= np.array([1,2,3,4,5])
v[0::2]   #forma de recorrer los elementos de un array
v[0]      #forma de acceder a alguno de los elementos
np.shape(v)    #me da el tamaño de la matriz

v0 = np.array([0,1,2,3,4,5])          #para la matriz cada uno de los elementos que construya en el posterior deben ser arreglos de numpy
v1= np.array([10,11,12,13,14,15])
v2= np.array([20,21,22,23,24,25])
v3= np.array([30,31,32,33,34,35])
v4= np.array([40,41,42,43,44,45])
v5= np.array([50,51,52,53,54,55])

w= np.array([v0, v1, v2, v3, v4, v5])
w

np.shape(w)    #para saber el tamaño de la matriz que he construido

w[0]     #de esta forma obtengo la fila
w[:,0]  #de esta forma accedo a los elementos de la columna

w[0, 3:5]  #de la fila uno muestra los elementos en las posiciones del 3 al 5

w[:, 4:]   #me muestra las columnas de la 4 en adelante

w[2:, 4:]   #de la fila 2 en adelante y de la columna 3 en adelante

w[4:, 4:]

"""#Solución del laboratorio

##Primera parte
"""

#r es la tasa de crecimiento de la poblacion
#x_0 poblacion inicial
#x_n poblacion despues de un timepo n
#programa que nos permita encontrar el numeor de la poblacion en un tiempo n particular

#PROHIBISO EL USO DE LISTAS --> USAR SOLO ARREGLOS DE NUMPY
#definir un vector lleno de ceros     x=np.zeros(n) --> donde n es el numero de tiempos que voy a definir

"""1. Programar la ecuación para el mapa logístico, y realizar una grafica del valor de xn como funcion de n."""

import numpy as np

def ec_mapa_logistico(r, n, x_0):
  ceros = np.zeros(n)
  ceros[0] = x_0
  for i in range(1,n):
    x_i = r * ceros[i-1] * (1-ceros[i-1])
    ceros[i] = x_i
  return ceros

x= ec_mapa_logistico(1.9, 100, 0.5)

plt.figure()
plt.plot(range(len(x)), x, label='r = 1.9')

plt.xlabel('n',fontsize= 14)
plt.ylabel('$x_n$',fontsize= 14)

plt.title('Mapa logístico',fontsize= 14)
###ponerle las etiquetas de los ejes


plt.legend(loc=1)   #pogo el loc para poner la posición en la que quiero ubicar el label'''

"""2. Realizar pruebas para un $x_0=0.5$, con valores de r

```
  r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
  numpoints = 100, # Numero sugerido de iteraciones
  x0 = 0.5
```

Organizar las gráficas [multiples plot](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html)

"""

r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
resultados = np.zeros((6, 100))                  #se crea un array de ceros correspondiente a dimensiones 6, 100     --> deseo generar 6 resultados, donde cada uno tiene una longitud de 100

for i in range(len(r)):
  resultados[i] =  ec_mapa_logistico(r[i], 100, 0.5)

#plt.plot?

fig, axs = plt.subplots(3, 2, figsize=(15,10))


x= range(100)    #el numero de elementos que quiero en la componente horizontal

axs[0, 0].plot(x, resultados[0], 'k',  label= 'r= 1.9')
axs[0, 0].set_title('Mapa logístico',fontsize= 14)
axs[0, 0].legend(loc='best')
axs[0, 0].set_xlabel('n',fontsize= 14)
axs[0, 0].set_ylabel('$x_n$',fontsize= 14)


axs[1, 0].plot(x, resultados[1], 'k', label= 'r= 2.9')
axs[1, 0].set_title('Mapa logístico',fontsize= 14)
axs[1, 0].legend(loc='best')
axs[1, 0].set_xlabel('n',fontsize= 14)
axs[1, 0].set_ylabel('$x_n$',fontsize= 14)

axs[2, 0].plot(x, resultados[2],'k', label= 'r= 3.1')
axs[2, 0].set_title('Mapa logístico',fontsize= 14)
axs[2, 0].legend(loc='best')
axs[2, 0].set_xlabel('n',fontsize= 14)
axs[2, 0].set_ylabel('$x_n$',fontsize= 14)

axs[0, 1].plot(x, resultados[3], 'm', label= 'r= 3.5')
axs[0, 1].set_title('Mapa logístico',fontsize= 14)
axs[0, 1].legend(loc='best')
axs[0, 1].set_xlabel('n',fontsize= 14)
axs[0, 1].set_ylabel('$x_n$',fontsize= 14)

axs[1, 1].plot(x, resultados[4], 'm', label= 'r= 3.9')
axs[1, 1].set_title('Mapa logístico',fontsize= 14)
axs[1, 1].legend(loc='best')
axs[1, 1].set_xlabel('n',fontsize= 14)
axs[1, 1].set_ylabel('$x_n$',fontsize= 14)

axs[2, 1].plot(x, resultados[5], 'm', label= 'r= 4.0')
axs[2, 1].set_title('Mapa logístico',fontsize= 14)
axs[2, 1].legend(loc='best')
axs[2, 1].set_xlabel('n',fontsize= 14)
axs[2, 1].set_ylabel('$x_n$',fontsize= 14)


fig.tight_layout()

"""3. Construye una rutina llamada logist_map en que entrada el valor de r, la condiciones inicial xi y el número de puntos determine la evolución en el punto N.  Prueba implementado las siguientes lineas.

```
Np = 1000
xf = np.zeros(Np)
r  = np.linspace(2.5, 4, Np)
 
for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r = r[i], xi = xini, N = 1000) 
  xf[i] = x_i
```

"""

#replicamos la misma función que fué creada en el primer punto --> la renombramos

def logist_map(r, xi, n):
  ceros = np.zeros(n)
  ceros[0] = xi
  for i in range(1,n):
    x_i = r * ceros[i-1] * (1-ceros[i-1])
    ceros[i] = x_i
  return ceros

Np = 1000
xf = np.zeros((1000, 1000))
r  = np.linspace(2.5, 4, Np)

for i in range(0, Np): 
  xini = np.random.random()
  x_i = logist_map(r = r[i], xi = xini, n = 1000) 
  xf[i] = x_i

xf


#se crean 1000 arrays en xf, donde cada uno corresponde a un valor diferente de r

"""4. Realiza un gráfico de:
```
  plt.plot((r-1/r), xf,  ".", markersize = 0.5)
```

"""

plt.plot((r-1/r), xf,  ".", markersize = 0.5)
;   #esto es para que no se imprima todo el texto que iba salir encima de la gráfica

"""5. Encontrar dos formas adicionales de expresar $f(x)$, para estos valores funcionales determinar las mismas gráficas del numeral 3 para cada uno de las formas de escribir la expresión. En este caso se espera que los resultados varien. ¿A que se debe esto?. La respuesta no es inmediata, constulta algunas fuentes para sacar tu propia conclusión.

"""

#notamos que lo que debemos hacer es encontar dos formas de reescribir la funcion

import numpy as np
import matplotlib.pyplot as plt

def ec_mapa_logistico_2(r, n, x_0):
  ceros = np.zeros(n)
  ceros[0] = x_0
  for i in range(1,n):
    x_i = r * ceros[i-1] - r * ceros[i-1]**2
    ceros[i] = x_i
  return ceros


r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
resultados_2 = np.zeros((6, 100))                  #se crea un array de ceros correspondiente a dimensiones 6, 100     --> deseo generar 6 resultados, donde cada uno tiene una longitud de 100

for i in range(len(r)):
  resultados_2[i] =  ec_mapa_logistico_2(r[i], 100, 0.5)

Np = 1000
xf = np.zeros((1000, 1000))
r  = np.linspace(2.5, 4, Np)

for i in range(0, Np): 
  xini = np.random.random()
  x_i = ec_mapa_logistico_2(r = r[i], n = 1000,  x_0 = xini) 
  xf[i] = x_i

plt.plot((r-1/r), xf,  ".", markersize = 0.5);

fig, axs = plt.subplots(3, 2, figsize=(15,10))


x= range(100)    #el numero de elementos que quiero en la componente horizontal

axs[0, 0].plot(x, resultados_2[0], 'k',  label= 'r= 1.9')
axs[0, 0].set_title('Mapa logístico',fontsize= 14)
axs[0, 0].legend(loc='best')
axs[0, 0].set_xlabel('n',fontsize= 14)
axs[0, 0].set_ylabel('$x_n$',fontsize= 14)


axs[1, 0].plot(x, resultados_2[1], 'k', label= 'r= 2.9')
axs[1, 0].set_title('Mapa logístico',fontsize= 14)
axs[1, 0].legend(loc='best')
axs[1, 0].set_xlabel('n',fontsize= 14)
axs[1, 0].set_ylabel('$x_n$',fontsize= 14)

axs[2, 0].plot(x, resultados_2[2],'k', label= 'r= 3.1')
axs[2, 0].set_title('Mapa logístico',fontsize= 14)
axs[2, 0].legend(loc='best')
axs[2, 0].set_xlabel('n',fontsize= 14)
axs[2, 0].set_ylabel('$x_n$',fontsize= 14)

axs[0, 1].plot(x, resultados_2[3], 'm', label= 'r= 3.5')
axs[0, 1].set_title('Mapa logístico',fontsize= 14)
axs[0, 1].legend(loc='best')
axs[0, 1].set_xlabel('n',fontsize= 14)
axs[0, 1].set_ylabel('$x_n$',fontsize= 14)

axs[1, 1].plot(x, resultados_2[4], 'm', label= 'r= 3.9')
axs[1, 1].set_title('Mapa logístico',fontsize= 14)
axs[1, 1].legend(loc='best')
axs[1, 1].set_xlabel('n',fontsize= 14)
axs[1, 1].set_ylabel('$x_n$',fontsize= 14)

axs[2, 1].plot(x, resultados_2[5], 'm', label= 'r= 4.0')
axs[2, 1].set_title('Mapa logístico',fontsize= 14)
axs[2, 1].legend(loc='best')
axs[2, 1].set_xlabel('n',fontsize= 14)
axs[2, 1].set_ylabel('$x_n$',fontsize= 14)


fig.tight_layout()

#miramos ahora una tercera forma de escribir la ecuación

import numpy as np
import matplotlib.pyplot as plt

def ec_mapa_logistico_3(r, n, x_0):
  ceros = np.zeros(n)
  ceros[0] = x_0
  for i in range(1,n):
    x_i = ceros[i-1] * (r - r * ceros[i-1])
    ceros[i] = x_i
  return ceros


r = np.array([1.9, 2.9, 3.1, 3.5, 3.9,4.0])
resultados_3 = np.zeros((6, 100))                  #se crea un array de ceros correspondiente a dimensiones 6, 100     --> deseo generar 6 resultados, donde cada uno tiene una longitud de 100

for i in range(len(r)):
  resultados_3[i] =  ec_mapa_logistico_3(r[i], 100, 0.5)

Np = 1000
xf = np.zeros((1000, 1000))
r  = np.linspace(2.5, 4, Np)

for i in range(0, Np): 
  xini = np.random.random()
  x_i = ec_mapa_logistico_3(r = r[i], n = 1000,  x_0 = xini) 
  xf[i] = x_i

plt.plot((r-1/r), xf,  ".", markersize = 0.5);

fig, axs = plt.subplots(3, 2, figsize=(15,10))


x= range(100)    #el numero de elementos que quiero en la componente horizontal

axs[0, 0].plot(x, resultados_3[0], 'k',  label= 'r= 1.9')
axs[0, 0].set_title('Mapa logístico',fontsize= 14)
axs[0, 0].legend(loc='best')
axs[0, 0].set_xlabel('n',fontsize= 14)
axs[0, 0].set_ylabel('$x_n$',fontsize= 14)


axs[1, 0].plot(x, resultados_3[1], 'k', label= 'r= 2.9')
axs[1, 0].set_title('Mapa logístico',fontsize= 14)
axs[1, 0].legend(loc='best')
axs[1, 0].set_xlabel('n',fontsize= 14)
axs[1, 0].set_ylabel('$x_n$',fontsize= 14)

axs[2, 0].plot(x, resultados_3[2],'k', label= 'r= 3.1')
axs[2, 0].set_title('Mapa logístico',fontsize= 14)
axs[2, 0].legend(loc='best')
axs[2, 0].set_xlabel('n',fontsize= 14)
axs[2, 0].set_ylabel('$x_n$',fontsize= 14)

axs[0, 1].plot(x, resultados_3[3], 'm', label= 'r= 3.5')
axs[0, 1].set_title('Mapa logístico',fontsize= 14)
axs[0, 1].legend(loc='best')
axs[0, 1].set_xlabel('n',fontsize= 14)
axs[0, 1].set_ylabel('$x_n$',fontsize= 14)

axs[1, 1].plot(x, resultados_3[4], 'm', label= 'r= 3.9')
axs[1, 1].set_title('Mapa logístico',fontsize= 14)
axs[1, 1].legend(loc='best')
axs[1, 1].set_xlabel('n',fontsize= 14)
axs[1, 1].set_ylabel('$x_n$',fontsize= 14)

axs[2, 1].plot(x, resultados_3[5], 'm', label= 'r= 4.0')
axs[2, 1].set_title('Mapa logístico',fontsize= 14)
axs[2, 1].legend(loc='best')
axs[2, 1].set_xlabel('n',fontsize= 14)
axs[2, 1].set_ylabel('$x_n$',fontsize= 14)


fig.tight_layout()

"""Notamos que en los 3, no hay una diferencia grande; sin embargo, se debe considerar que al cambiar la forma de la ecuación, la propagación del error también va cambiar.

##Segunda parte

**Su tarea será**:

1. Disenar un programa, en el que entrada la función y su derivada, definidas como funciones lambda de python, se determine el valor mínimo de esa función. 
Prueba tu algoritmo para  la función $f(x) = x^2$
"""

#funcion_ingresada= lambda x: input('Ingrese la función en términos de la variable independiente x: ')
#derivada_ingresada = lambda x: input('Ingrese la derivada en términos de la variable independiente x: ')

#ingreso = funcion_ingresada('ingresar'), derivada_ingresada('ingresar')        
#funciones = tuple(eval(elem) for elem in ingreso)    #puedo usarlo para cuando vaya a hacer la evalución en una función mas adelante

import numpy as np

funcion = lambda x: x**2
derivada = lambda x: 2*x

def gradiente_descendente(funcion, derivada, x_0 = 5, α=0.2):

  valores= np.empty(shape=(0,), dtype=float)           #creo una matriz vacia que va contener elementos de tipo float, y de dimensiones 0 filas y las columnas correspondientes a la cantidad de elementos qe ingrese
  
  valores= np.append(valores, x_0)
  x_1= x_0 - α * derivada(x_0)
  valores= np.append(valores, x_1)             #comienzo poniendo dos valores manualmente, para luego proceder a ejecutar un while
  
  iteraciones=2

  while valores[-2] > valores[-1]:       #para cuando los valores dejan de descender
    x_i = valores[-1] - α * derivada(valores[-1])
    valores= np.append(valores, x_i)
    iteraciones += 1
  return valores[-1], iteraciones, valores

gradiente_descendente(funcion, derivada)[0]

"""Observación: el anterior es el código realizado por mi.\
A continuacion presento un código mejorado por el chat gpt, donde me sugiere considerar un valor de tolerancia, tal que la funcion de gradiente descendente converja a una solución más optima.\
Segun chat GPT: "se recomienda elegir una tolerancia que sea lo suficientemente pequeña para proporcionar una solución precisa, pero no tan pequeña que se vuelva computacionalmente ineficiente o propensa a errores numéricos."
"""

import numpy as np

def gradiente_descendente_2(funcion, derivada, x_0=5, α=0.2, max_iter=100):
    valores = np.empty(shape=(0,), dtype=float)
    valores = np.append(valores, x_0)
    iteracion = 1

    while iteracion < max_iter:
        x_i = valores[-1] - α * derivada(valores[-1])
        valores = np.append(valores, x_i)
        iteracion += 1
        if abs(valores[-2] - valores[-1]) < 1e-6:
            break

    print("El gradiente descendente convergió después de {} iteraciones".format(iteracion))
    return valores[-1], iteracion, valores

gradiente_descendente(funcion, derivada)

"""Notamos que en efecto el valor que se obtiene con el código mejorado es de menos ordenes de magnitud que el obtenido con mi código, debido a la tolerancia que se ha incluido en él.

2. Realiza el grafico de la funcion y la derivada, especifica la leyenda de cada curva empleando el metodo legend() de matplotlib.
"""

import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 2, figsize=(15,7))


x= np.arange(100)  
y= np.array([funcion(i) for i in x])

axs[0].plot(x, y, 'm',  label= '$x^2$')
axs[0].set_title('Función $x^2$',fontsize= 14)
axs[0].legend(loc='best')
axs[0].set_xlabel('$x$',fontsize= 14)
axs[0].set_ylabel('$f(x)$',fontsize= 14)

y_2= y= np.array([derivada(i) for i in x])
axs[1].plot(x, y, 'm', label= '2x')
axs[1].set_title('Derivada de $x^2$',fontsize= 14)
axs[1].legend(loc='best')
axs[1].set_xlabel('$x$',fontsize= 14)
axs[1].set_ylabel('$f(x)$',fontsize= 14)

"""3. Analiza como se minimiza la función, gráficando de la funcion en cada punto a iterar,  como funcion del numero de iteraciones. Para dos valores diferentes de la constante alpha (prueba con $\alpha=0.1$, $\alpha=0.01$)"""

#primero lo hacemos teniendo mi código

fig, axs = plt.subplots(1, 2, figsize=(15,7))


x= np.arange(gradiente_descendente(funcion, derivada, x_0 = 5, α = 0.1)[1])   #en el eje x va ir el numero de iteraciones
y= gradiente_descendente(funcion, derivada, x_0 = 5, α = 0.1)[2]      #acá va los valores correspondientes a cada una de las iteraciones

axs[0].plot(x, y, 'm',  label= 'Gradiente descendente')
axs[0].set_title('Gradiente descendente, α = 0.1',fontsize= 14)
axs[0].legend(loc='best')
axs[0].set_xlabel('# de iteraciones',fontsize= 14)
axs[0].set_ylabel('valor de la funcion',fontsize= 14)

x_2= np.arange(gradiente_descendente(funcion, derivada, x_0 = 5, α = 0.01)[1])   #en el eje x va ir el numero de iteraciones
y_2= gradiente_descendente(funcion, derivada, x_0 = 5, α = 0.01)[2]      #acá va los valores correspondientes a cada una de las iteraciones

axs[1].plot(x, y, 'm',  label= 'Gradiente descendente')
axs[1].set_title('Gradiente descendente, α = 0.01',fontsize= 14)
axs[1].legend(loc='best')
axs[1].set_xlabel('# de iteraciones',fontsize= 14)
axs[1].set_ylabel('valor de la funcion',fontsize= 14)

#ahora, teniendo en cuenta las consideraciones realiadas por el chat GPT

x= np.arange(gradiente_descendente_2(funcion, derivada, x_0 = 5, α = 0.1)[1])   #en el eje x va ir el numero de iteraciones
y= gradiente_descendente_2(funcion, derivada, x_0 = 5, α = 0.1)[2]      #acá va los valores correspondientes a cada una de las iteraciones

plt.plot(x,y, label= 'Gradiente descendente')
plt.xlabel('# de iteraciones', fontsize=14)
plt.ylabel('valor de la funcion', fontsize= 14)
plt.title('Gradiente descendente, α = 0.1')

plt.legend();

x= np.arange(gradiente_descendente_2(funcion, derivada, x_0 = 5, α = 0.01)[1])   #en el eje x va ir el numero de iteraciones
y= gradiente_descendente_2(funcion, derivada, x_0 = 5, α = 0.01)[2]      #acá va los valores correspondientes a cada una de las iteraciones

plt.plot(x,y, label= 'Gradiente descendente')
plt.xlabel('# de iteraciones', fontsize=14)
plt.ylabel('valor de la funcion', fontsize= 14)
plt.title('Gradiente descendente, α = 0.01')

plt.legend();

"""Notamos que en el caso de la funcion realizada por mi, no se observa una diferencia cuando se consideran los valores de $α$ iguales a 0.1 y 0.01, debido a que como no se establecieron restricciones en cuanto a un valor de convergencia promedio, la funcion realiza un numero grande de iteraciones y decae rápidamente con relación a las iteraciones realizadas.

Por otro lado, cuando se grafica la funcion mejorada con el chat GPT, es notoria la diferencia cuando se consideran los dos valores de $\alpha$, debido a que el numero de iteraciones es menor en comparacion con mi código.
"""