# -*- coding: utf-8 -*-
"""Lab06_ceros_funciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11wys1ioVHMVJPqW6Lo8EwKQYnhzPlVpG

>[Codigo Markdown:](#scrollTo=HmTyV2-NQKwR)

>[Ceros de funciones](#scrollTo=UCFMTQZz-Y6l)

>>[bisección](#scrollTo=P0L8RdCVKZmb)

>>[Newton](#scrollTo=Y7x6yKhhOPMU)

>>[punto fijo](#scrollTo=1BFswTuxOTjC)

>[Partícula en reposo](#scrollTo=DIOVE0E1XZ1-)

>[Area](#scrollTo=3SVJWnEeVcAP)

>[Movimiento de proyectiles en presencia de viento.](#scrollTo=zxQOD2FgQIfM)

>[Construir un fractal empleando el metodo de Newton-Raphson,](#scrollTo=Ok4b668dWU_A)

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab06_ceros_funciones.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Codigo Markdown:
Los numeras a, b, c y d tiene que ver con escritura en código Markdown y comandos de latex:

a. Escriba en pseudocódigo los pasos para aplicar el método de la bisección.

A continuación se presneta el peusocódigo correspondiente a los pasos que hay detrás de la aplicación del método de la bisección.

Al momento de aplicar el método no es necesario crear un código que realice estos pasos, sino que se puede hacer lo siguiente:

```
from scipy import optimize

optimize.bisect(función, punto 1, punto 2, argumentos)         #nos da el valor de la raíz

```
De aquí, es importante resaltar que el signo de funcion(punto 1) debe ser contrario a signo de funcion(punto 2), para que se pueda satisfacer el teorema del valor medio

```
input: a, b, tol, maximo numero de iteraciones N_0

output: p --> aproximación al valor de la raiz de la función (en caso de exixtir en el intervalo (a,b)

PASO 1:
i =1
a_1 =a
b_1 =b

PASO 2:
while i< N_0, realizar los pasos del 3 al 6

  PASO 3:
    calcular p = (a_1 + b_1) / 2

  PASO 4:
    si f(p)==0 ó (b-a) / 2 < tol entonces          #si el punto medio entre la distancia de los dos puntos que se han elegido 
                                                   es menor a una tolerancia
    OUTPUT p
    END

  PASO 5: 
    reasignar i += 1

  PASO 6: 
    si f(a) * f(p) > 0 entonces
    reasignar a = p

    else 
    reasignar b = p 

OUTPUT ('Método fallido después de N_0 iteraciones')
END
```

b. Realice la deducción del metodo de Newton-Rapshon, se recomienda escribir las ecuaciones en formato latex, para ello puede emplear las siguientes expresiones:   LA DEDUCCION EN DETALLE SE ENCUENTRA EN EL LIBRO DE BURDEN

Sea f una función de clase $C^2$ en el intervalo [a,b]. 

Sea $p_0$ perteneciente a [a, b] ser una aproximación al valor de la raiz de la funcion $p$, tal que $f(p_o) \neq 0$.

Consideramos la expansión de taylor para función f, centrada en el punto p_0:



\begin{equation}
  f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n
\end{equation}


Ahora, evaluamos la anterior expresión en el punto x= p


\begin{equation}
  f(p) = 0 = \sum_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(p-x_0)^n
\end{equation}

Como $|p-p_0|$ es pequeño (bajo la suposicion de que $p_0$ es un numero cercano a la raíz $p$ de la función, entonces podemos despreciar los términos después del segundo orden de esta serie, tal que:

\begin{equation}
  f(p) = 0 = f(x_0) + f'(x_0)(p-x_0)
\end{equation}

Por lo tanto, al despejar $p$, tenemos que:

\begin{equation}
  p = x_0 - \frac{f(x_0)}{f'(x_0)}
\end{equation}

Lo anterior es lo que nos va dar la idea de como funciona el proceso de iteración a través del método de Newton - Raphson, tal que lo que vamos a hacer es generar una secuencia $\{p_n\}_{n=0}^{\infty} \quad$, donde para $n\geq 1$:

\begin{equation}
  p_n = p_{n-1} - \frac{f(p_{n-1})}{f'(p_{n-1})\quad},           
\end{equation}

sin embargo, es importante resaltar que el objetivo del proceso no es realizarlo infinitas veces, sino establecer una tolerancia (tol), tal que cuando $|p_n - p_{n-1}|$ < tol, entonces el proceso pare.

c. ¿Cuál es la diferencia del metodo de Newton-Rapson con respecto al de la secante?

La diferencia entre la aplicación de estos dos métodos viene esencialmente determinada por la presencia y uso de la derivada de la función para el cálculo de la raíz.

Para encontrar las raices de una función $f(x)$ a través del método de Newton-Raphson, es necesario conocer la derivada de la función, y proporcionar un punto; mientras que para desarrollarlo por el método de la secante basta con proporcionar dos puntos de la función que se encuentren cercanos a la raiz.

Ee importante resaltar que el punto o los puntos que se ingresen a cada uno de los métodos deben ser cercanos al valor de la raíz, con el fin de evitar problemas de convergencia. Sin embargo, aún tomando valores cercanos existe la posibilidad de que el resultado diverja a razón de los valores que fueron considerados

d. Escriba en pseudocódigo los pasos para aplicar el método Punto Fijo.

A continuación se presenta el peusocódigo correspondiente a los pasos que hay detrás de la aplicación del método del punto fijo.

Al momento de aplicar el método no es necesario crear un código que realice estos pasos, sino que se puede hacer lo siguiente:

```
from scipy import optimize

optimize.fixed_point(func, p_0, args)

tal que func es la función que hemos definido de la siguiente manera:

Sea f la función a la cual le deseamos encontrar la raiz, entonces:
func(x) = x - f(x)

```
De aquí, es importante resaltar que el valor de p_0 debe ser cercano a la raiz, y que la funcion que se ingresa no es a la que le queremos encontrar la raíz, sino una que definimos de la manera descrita previamente

```
INPUT punto aproximado al valor de la raiz p_0,tolerancia, máximo numero de iteraciones N0
OUTPUT valor aproximado de la raíz, o mensaje de error

PASO 1:
  definir i=1

PASO 2:  
  while i=<N0, realizar los pasos 3 al 6

  PASO 3:
    definir p=g(p0)                    # se van a ir definiendo diferenetes puntos p_i

  PASO 4:
    si |p-p0|<tol entonces             #cuando abs(dif(dos de los puntos calculados))es pequeña
      output p, END

  PASO 5: 
    redefinir i += 1

  PASO 6:
    redefinir p0=p                     #de modo que cuando vuelva al paso 3, p = g(g(p0))

PASO 7:
  OUTPUT ('el procedimiento ha fallado luego de N0 iteraciones')
  END
```

# 2. Ceros de funciones
*Encontrar* los ceros de $e^{x}-2= \cos(e^x-2)$ por diferentes metodos, bisection, newton-rapshon, punto fijo.
"""

import numpy as np
from scipy import optimize
import matplotlib.pyplot as plt


def func(x):
  return np.exp(x) - 2 - np.cos(np.exp(x) - 2 )

x= np.linspace(-1, 2)     #vamos a considerar un intervalo pequeño, en el cual podamos identificar una raiz
y= func(x)

plt.plot(x, y)

"""##bisección"""

# vamos a encontrar las raices de la funcion por medio del metodo de la bisección

a=-5
b=5

raiz=  optimize.bisect(func, a, b)
print(f'la raiz de la función es {raiz}')

x= np.linspace(-1, 2)    
y= func(x)

plt.plot(x, y, label=f'{round(raiz, 4)}')
plt.plot(raiz, func(raiz), 'ro')
plt.grid()
plt.title('Bisección')
plt.legend(loc='best');

"""##Newton"""

#recordamos que para aplicar el método de newton debemos calcular la derivada de la función

import sympy as sp

def func(x):
  return np.exp(x) - 2 - np.cos(np.exp(x) - 2 )

#vamos a calcular la derivada de la función

x= sp.symbols('x')
f= lambda x: sp.exp(x) - 2 - sp.cos(sp.exp(x) - 2 )
der = sp.diff(f(x), x)
der

der_1= sp.lambdify(x, der, 'numpy')     #convertimos la función que sale de sympy a una función de numpy con la cual podemos trabajar, ingresando primero los argumentos, luego la función, y luego numpy, que es a lo que la queremos convertir
der_1

print(f' el valor de la raiz de la función tomando x_0 = 1 es {optimize.newton(func, 0.5, der_1)}')

"""##punto fijo"""

#defino la función que es la que debo ingresar en el método de punto fijo


def g(x):
  return x- func(x)

print(f'el valor de la raiz usando el método del punto fijo es {optimize.fixed_point(g, 1)}')

"""Notamos que por los tres métodos obtenemos el mismo resultado cuando consideramos un punto inicial cercano a la raíz (se elige el punto con base a la inspección de la gráfica de la función)

#3. Partícula en reposo
Una particula parte del reposo sobre un plano inclinado uniforme, cuyo ángulo 
$\theta$ cambia con una rapidez constante de : 

\begin{equation}
\frac{\mathrm{d}\theta}{\mathrm{d} t} = \omega < 0
\end{equation}

Al final de t segundos, la posición del objeto esta dada por: 


\begin{equation}
x(t) = -\frac{g}{2\omega^2} \left( \frac{e^{\omega t}-e^{-\omega t}}{2}-\sin\omega t\right) 
\end{equation}

Suponga que la particula se desplazo 0.51m en 1s. Encuentre, con exactitud de $10^{-5}$ la rapidez $\omega$ con que cambia $\theta$. Supoga $g=9.76$m/s
"""

#de acuerdo con lo que nos dicen en el problema, lo que debemos hacer es resolver es la siguiente ecuacion:

import numpy as np

def fun(w):
  g= 9.76
  return (-g / (2* w**2)) * ((np.exp(w) - np.exp(-w)) / 2 - np.sin(w))  - 0.51

#debemos resolver la anterior ecuacion para w.
#lo que hacemos es una gráfica, para darnos una intuición de donde podría estar el cero de la función

import matplotlib.pyplot as plt

x= np.linspace(-2, -0.000005)
y= fun(x)
ceros= np.zeros(50)

plt.plot(x,y)
plt.plot(x, ceros)
plt.grid();

#encontremos la raíz por medio del método del punto fijo

#definimos la funcion que vamos a usar en la aplicación del punto fijo

def ec(w):
  return w- fun(w)

from scipy import optimize

raiz= optimize.fixed_point(ec, -0.25, xtol=1e-05)
print(f'utilizando el método del punto fijo, se encuentra que la raíz de la función es {optimize.fixed_point(ec, -0.25)}')

#graficamos el punto

x= np.linspace(-2, -0.000005)
y= fun(x)

plt.plot(x,y)
plt.plot(raiz, fun(raiz), 'ro')
plt.grid();

"""Concluimos que la rapide con la que cambia $\theta$ es aproximadamente de -0.313 $\frac{rad}{seg}$

#3.  Area 
Hallar el área de un segmento circular cuya area sea igual a una cuarta parte del área del circulo. Para la solución se sugiere lo siguiente:

a) Encontrar la ecuacion trascendental.

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python.

c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre $[-2\pi, 2\pi]$. Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2*np.pi, 2*np.pi, 1000 )

d) Construir una segunda columna titulada "F_theta" con los registros f(theta)

f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz.

Estime el valor del ángulo empleando los siguientes metodos(Emplee  la documentacion):

g) [Bisección](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html)

h) [Newton-Rapshon](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)

i) [Secante](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) 

j) [Punto Fijo](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html)

a) Encontrar la ecuacion trascendental.

Al lado izquierdo tenemos la ecuacion correspondiente a la cuarta parte del área de un círulo.

Al lado derecho se encuentra la ecuacion correspondiente al área del segmento circular.

IMPORTANTE: el valor de $\theta$ debe ingresarse en radianes y $r$ representa el radio de la circuenferencia

\begin{equation}
  \frac{1}{4}\pi r² = \frac{r²}{2}(\theta- sin(\theta))
\end{equation}

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python.
"""

ec= lambda θ: θ - np.sin(θ) - (np.pi / 2 )

"""c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre $[-2\pi, 2\pi]$. Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2*np.pi, 2*np.pi, 1000 )

d) Construir una segunda columna titulada "F_theta" con los registros f(theta)
"""

import pandas as pd

θ = np.linspace(-2 * np.pi, 2*np.pi, 1000)

df = pd.DataFrame()
df['θ'] = θ
df['f(θ)'] = df['θ'].apply(ec)    #aplicamos nuestra funcion lambda a la primera columna correspondiente a los valores de theta que hemos elegido

df


#teniendo los valores de f(θ), debemos ver ahora cuales son los que satisfacen la ecuacion f(θ)= 0

"""f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz.

"""

ceros= np.zeros(1000)

plt.plot(df['θ'], df['f(θ)'])
plt.plot(df['θ'], ceros)
plt.title('$f(θ)$ vs. $θ$')
plt.grid()

"""g) [Bisección](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html)"""

#ahora, aplico el método de la bisección en el intervalo que se observa en la gráfica, para graficarlo también

raiz= optimize.bisect(ec, 2,3)
raiz

plt.plot(df['θ'], df['f(θ)'])
plt.plot(raiz, ec(raiz), 'ro', label=f' θ = {round(raiz, 3)}')
plt.title('$f(θ)$ vs. $θ$')
plt.grid()
plt.legend(loc= 'best')

"""h) [Newton-Rapshon](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)"""

#para emplear el método de newton raphson comenzamos por definir la derivada de la función

ec= lambda x: x - np.sin(x) - (np.pi / 2 )

import sympy as sp

x= sp.symbols('x')
fun= lambda x: x - sp.sin(x) - (sp.pi / 2 )
dif= sp.diff(fun(x), x)
dif_1 = sp.lambdify(x, dif, 'numpy')

print(f'la raíz de la función cercana al punto θ = 2 es: {optimize.newton(ec, 2, dif_1)}')

"""i) [Secante](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) """

ec= lambda x: x - np.sin(x) - (np.pi / 2 )

#podemos hacerlo haciendo uso del método optimize.root_scalar()

raiz= optimize.root_scalar(ec, bracket=[2, 4])     #proporciono los dos puntos que se necesitan para llevar a cabo el procedimiento de la secante
print(f' la raíz de la función cercana al punto x=2 es {raiz.root}')

#o bien lo podemos hacer de esta forma

raiz = optimize.newton(ec, 2, fprime=None)   
print(f'la raíz de la función cercano al punto x=2 a través del metodo de la secante es {raiz}')

"""j) [Punto Fijo](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html)

"""

ec= lambda x: x - np.sin(x) - (np.pi / 2 )

#definimos la función que vamos a ingresar al método

fun = lambda x: x- ec(x)

raiz = optimize.fixed_point(fun, 2)     #nos acercamos nuevamente por x=2
print(f'la raíz de la función con el método del punto fijo es {raiz}')

"""Notamos que a través de todos los métodos obtenemos siempre el mismo resultado de la raíz

# 3. Movimiento de proyectiles en presencia de viento.

Supongamos que un proyectil es lanzado desde el origen con una rapidez $v=vo( \cos \theta , \sin \theta $. Supongamos además que el efecto del viento sobre el proyectil es el de una fuerza proporcional a la velocidad relativa entre el viento y el proyectil. Teniendo presente que si u es la velocidad del viento y $\alpha$ el ángulo que hace dirección de esta velocidad con el eje x, se puede entrontrar las siguientes ecuaciones diferenciales, asociada al estado de movimiento del [proyectil](https://iopscience.iop.org/article/10.1088/0143-0807/36/2/025016/meta):


\begin{equation}
m\frac{dv_x}{dt} = -mb(v_x-u\cos \alpha )
\end{equation}

\begin{equation}
m\frac{dv_y}{dt} = -mg-mb(v_x-u\sin \alpha ),
\end{equation}

donde b es el párametro de rozamiento. La soluciones a las ecuaciones anteriores vienen dadas por:

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}

Ver imagen:  http://www.sc.ehu.es/sbweb/fisica3/fluidos/viento/parabolico.html

0. Establezca las siguietnes condiciones inciales.

```
#Parametros iniciales

v0 = 60 #Velocidad en m/s
alpha = np.pi #Angulo del viento
theta = np.deg2rad(45) #Angulo de lanzamiento
u = v0/2             #rapidez del viento
b = 0.05             #Parametro de friccion 
g = 9.8                #Aceleracion de la gravedad m/s2

Params = (alpha, v0, b, u,g)  #Parametros en tupla.

```
"""

import numpy as np

# Parametros iniciales

v0 = 60                 #Velocidad en m/s
alpha = np.pi           #Angulo del viento
theta = np.deg2rad(45)  #Angulo de lanzamiento
u = v0/2                #rapidez del viento
b = 0.05                #Parametro de friccion 
g = 9.8                 #Aceleracion de la gravedad m/s2

Params = (alpha, v0, b, u,g)  #Parametros en tupla.

"""1. Defina dos funciones, una para x y otra para y. 

```

#Posicion en x
def pos_x(t, theta, alpha, v0, b, u,g):
  x = #escriba aca la expresión
  return x

#Posicion en y
def pos_y(t, theta, alpha, v0, b, u,g):


  y = #escriba aca la expresión
  return y 

```

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}
"""

# Posicion en x
def pos_x(t, theta, alpha, v0, b, u,g):
  x = (u * np.cos(alpha))* t + (1/b) * (v0 * np.cos(theta) - u * np.cos(alpha)) * (1- np.exp(-b * t))
  return x

# Posicion en y
def pos_y(t, theta, alpha, v0, b, u,g):
  y = (1/b) * ((g/b) + v0 * np.sin(theta) - u * np.sin(alpha)) * (1- np.exp(-b * t)) - ((g/b) - u * np.sin(alpha)) *t
  return y

"""2. Construya un diccionario con las claves "X", "Y", "Tiempo"
"""

#lo defino de tal forma que despues lo pueda rellenar

dic = {'t': [], 'x': [], 'y': []}

"""3. Con el diccionario construya un data frame de pandas llamado df con los nombres de columnas "X", "Y", "Tiempo"  https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html. Defina 1000 regitros para el intervalo de tiempo elegido."""

import pandas as pd

df= pd.DataFrame(dic)
df

#vamos ahorora a general los registros solicitados, desde el tiempo 0 a 1000-1

df['t'] = np.arange(1000)
df['x'] = df['t'].apply(lambda t: pos_x(t, theta, alpha, v0, b, u, g))            #para poder aplicar la función a los elementos de la primera columna, redefino una función lambda tal que tome los demás argumentos como las condiciones iniciales que había definido previamente
df['y'] = df['t'].apply(lambda t:pos_y(t, theta, alpha, v0, b, u, g))
df

#podemos visualizar el anterior dataframe nuevamente como un diccionario

#df.to_dict()

"""4. Realice un gráfico de x como función del tiempo, de y como función del tiempo y la trayectoria de la partícula (df["X"], df["tiempo"], df["Y"]).


"""

#veamos primero la gráfica de 

import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 2)


axs[0].plot(df['t'], df['x'], label='1000 valores')
axs[0].set_title('x vs. t')
axs[0].set_xlabel('t')
axs[0].set_ylabel('x')
axs[0].legend()

axs[1].plot(df['t'][:50], df['x'][:50], label='50 valores')    
axs[1].set_title('x vs. t')
axs[1].set_xlabel('t')
axs[1].set_ylabel('x')
axs[1].legend()

fig.tight_layout()

fig, axs = plt.subplots(1, 2)


axs[0].plot(df['t'], df['y'], label='1000 valores')
axs[0].set_title('y vs. t')
axs[0].set_xlabel('t')
axs[0].set_ylabel('y')
axs[0].legend()

axs[1].plot(df['t'][:50], df['y'][:50], label='50 valores')    
axs[1].set_title('y vs. t')
axs[1].set_xlabel('t')
axs[1].set_ylabel('y')
axs[1].legend()

fig.tight_layout()

#veamos ahora la gráfica de la trayectoria de la partícula

fig, axs = plt.subplots(1, 2)


axs[0].plot(df['x'], df['y'], label='1000 valores')
axs[0].set_title('y vs. x')
axs[0].set_xlabel('x')
axs[0].set_ylabel('y')
axs[0].legend()

axs[1].plot(df['x'][:50], df['y'][:50], label='50 valores')      #consideramos los primeros valores, para visualizar lo que pasa en los primeros segundos del problema 
axs[1].set_title('y vs. x')
axs[1].set_xlabel('x')
axs[1].set_ylabel('y')
axs[1].legend()
axs[1].grid()


fig.tight_layout()

"""5. Determine el alcance máximo de la partícula, para ello tome  la solucion teórica con $y=0$, solucione numéricamente la ecuación para t y remplace este valor en la ecuación para x. Resuelvalo para $\theta=45^{o}$. """

#recordamos la funcion pos_y y cambiamos su nombre

def y(t, theta, alpha = np.pi, v0 = 60, b = 0.05, u = 30, g = 9.8):
  y = pos_y(t, theta, alpha = np.pi, v0 = 60, b = 0.05, u = 30, g = 9.8)
  return y 

theta = np.deg2rad(45)

#queremos encontrar el cero de la función, y vamos a tener en cuenta que lo haremos en el rango entre 10 y 80 grados

#independiente del método que vayamos a utilizar, necesitamos un punto que sea cercano a la raiz
#vamos a inspeccionar en cada uno de los casos cuándo ocurre un cambio de signo

def y_(t, theta):
  return y(t, np.deg2rad(theta))   #de modo que pueda ingresar el valor en grados

df = pd.DataFrame({'t' : []})
df['t'] = [i for i in range(1000)]

for i in np.arange(10, 85, 5):
  df[f'y para θ = {i}°'] = df['t'].apply(lambda t: y_(t, i))

df

#ahora, para cada uno de los ángulos, vamos a encontrar un punto que sea cercano a la raiz

angulos=np.arange(10,85,5)
puntos_a_evaluar_y= np.zeros(15)
p_pos_y= np.zeros(15)

p=0
for i in angulos:
  count= 2
  signo_inicial = df[f'y para θ = {i}°'][1]      #signo del primer elemento de cada columna
  for k in df[f'y para θ = {i}°'][1:]:           #tomamos cada elementos de cada columna y lo multiplicamos por el siguiente
    valor = k* df[f'y para θ = {i}°'][count]
    count += 1
    if valor * signo_inicial < 0:                #rompemos el ciclo y guardamos el valor anterior al cambio de signo
      puntos_a_evaluar_y[p] = k
      p_pos_y[p] = df[f'y para θ = {i}°'][count]
      break
  p+=1

puntos_a_evaluar_y , p_pos_y

#los valores que obtuve son los cambios de signo, pero correspondientes al valor de y, debo ver cual es su preimagen, es decir, el valor de t

angulos=np.arange(10,85,5)
puntos_a_evaluar_x= np.zeros(15)
p_pos_x= np.zeros(15)

count= 0
for i in angulos:
  x= np.where(df[f'y para θ = {i}°'] == puntos_a_evaluar_y[count])
  x_1= np.where(df[f'y para θ = {i}°'] == p_pos_y[count])
  puntos_a_evaluar_x[count] = x[0]
  p_pos_x[count] = x_1[0]
  count +=1

puntos_a_evaluar_x , p_pos_x, len(puntos_a_evaluar_x)

#como ya tenemos los puntos a evaluar, podemos encontrar el cero de función a través del método de la bisección

from scipy import optimize

raices = np.zeros(15)

for i in range(15):
  raiz= optimize.bisect(y_, puntos_a_evaluar_x[i], p_pos_x[i], args=(angulos[i],))
  raices[i] = raiz

raices

#la raiz correspondiente al ángulo 45° es raices[7]
#por lo cual, para calcular el alcance máximo, vamos a evaluar la función de x en el tiempo que obtuvimos


def pos_x(t, theta, alpha, v0, b, u,g):
  x = (u * np.cos(alpha))* t + (1/b) * (v0 * np.cos(theta) - u * np.cos(alpha)) * (1- np.exp(-b * t))
  return x

def x(t, theta):
  return pos_x(t, theta, np.pi, 60,  0.05, 30, 9.8)
  
def x_(t, theta):
  return x(t, np.deg2rad(theta))

max_x_45= x_(raices[7], 45)
print(f'el alcance máximo de la partícula bajoa las condiciones iniciales establecidas y con un ángulo de 45° es {max_x_45} metros')

"""
 

6. Construya una  grafica del alcance máximo R como función de $\theta$, varie $\theta$  entre 10 y 80 grados cada 5 grados."""

#obtengamos ahora el alcance máximo de la partícula para cada uno de los ángulos que se pide

alcance_max= []

count=0
for i in angulos:
  alcance = x_(raices[count], i)
  alcance_max.append(alcance)
  count+=1

R= alcance_max
angulo = angulos

plt.plot(angulo, R)
plt.grid()
plt.title('alcance máximo como funcion de θ')
plt.xlabel('θ°')
plt.ylabel('alcance máximo (m)');

"""# 4. Construir un fractal empleando el metodo de Newton-Raphson, 
(Reproducir código y entender)
\begin{equation}
z_{n+1} = z_n -a \frac{f(z)}{f'(z)} 
\end{equation}



\begin{equation}
f'(z) = \frac{ f(z+h)+f(z) }{h}
\end{equation}

```
import numpy as np
import matplotlib.pylab as plt
from PIL import Image

Npx_X = 80 #Numero de pixeles en x
Npx_Y = 80 #Numero de pixeles en y

image = Image.new("RGB", (Npx_X, Npx_Y)) #Creacion de la imagen inicial

npx = np.arange(0, Npx_X)
npy = np.arange(0, Npx_Y)

xmin = -1
xmax = 1
ymin = -1
ymax = 1
#Transformación al plano complejo en un rectangulo (xmin, xmax), (ymin, ymax)
zx = npx * (xmax - xmin) / (Npx_X - 1)   + xmin
zy = npy * (ymax-ymin) / (Npx_Y - 1) + ymin

#Definicion  la funcion y las derivada 
def f(z): 
  return z**3 - 1

def fp(z): 
  return 3*z**2

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)
```
"""

import numpy as np
import matplotlib.pylab as plt
from PIL import Image

Npx_X = 80 #Numero de pixeles en x
Npx_Y = 80 #Numero de pixeles en y

image = Image.new("RGB", (Npx_X, Npx_Y)) #Creacion de la imagen inicial

npx = np.arange(0, Npx_X)
npy = np.arange(0, Npx_Y)

xmin = -1
xmax = 1
ymin = -1
ymax = 1
#Transformación al plano complejo en un rectangulo (xmin, xmax), (ymin, ymax)
zx = npx * (xmax - xmin) / (Npx_X - 1)   + xmin
zy = npy * (ymax-ymin) / (Npx_Y - 1) + ymin

#Definicion  la funcion y las derivada 
def f(z): 
  return z**3 - 1

def fp(z): 
  return 3*z**2

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)

###vamos a comenzar a cambiar algunos valores para obtener fractales diferentes

#Definicion  la funcion y las derivada 
def f(z): 
  return (1-z)**4 - 1

def fp(z): 
  return -4 * (1-z)**3

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)

#Definicion  la funcion y las derivada 
def f(z): 
  return np.exp(z) * np.sin(z)

def fp(z): 
  return np.exp(z) * np.sin(z) + np.exp(z) * np.cos(z)

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)

#Definicion  la funcion y las derivada 
def f(z): 
  return z

def fp(z): 
  return 1

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )

plt.imshow(image)
#plt.xlim(400, 600)
#plt.ylim(400, 523)