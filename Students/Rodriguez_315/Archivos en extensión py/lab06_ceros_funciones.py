# -*- coding: utf-8 -*-
"""Lab06_ceros_funciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jtOo_OJpworuZN-O2Jy1hm3bWFZcuvfd

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Laboratorios_Taller/Lab06_ceros_funciones.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Codigo Markdown:
Los numeras a, b, c y d tiene que ver con escritura en código Markdown y comandos de latex: 

a. Escriba en pseudocódigo los pasos para aplicar el método de la bisección.

b. Realice la deducción del metodo de Newton-Rapshon, se recomienda escribir las ecuaciones en formato latex, para ello puede emplear las siguientes expresiones:

c. ¿Cuál es la diferencia del metodo de Newton-Rapson con respecto al de la secante?


d. Escriba en pseudocódigo los pasos para aplicar el método Punto Fijo.



Comentarios para escribir en latex

*   Entre simbolos \$ \$, puedes porner expresiones  puede poner expresiones, ejemplo:  $y = a_0 x^2 + b_1$  

*  Las funciones pueden ser definidas entre \\$,  poniendo un \\, antes de la funcion ejemplo: \\$ \\sinx \\$,   asi las funciones quedarian de esta manera : 

> $\sin x$, $\tan x$, $\sec x$, $\sqrt{a} $, $\frac{a}{b}, \frac{df}{dt}$

* Puedes generar tambien escribir ecuaciones con la instrucción:

  \\begin{equation} 

    \\sin x  
  
  \\end{equation}

Ejemplo:

  \begin{equation} 
    \frac{df}{dx} = \sin x  
  \end{equation}

a. Escriba en pseudocódigo los pasos para aplicar el método de la bisección.

###**Método De Bisección**
1. Definimos un intervalo [a,b] en el cual al evaluar la función halla un cambio de signo. Esto es: $f(a)<0$ y $f(b)>0$
2. Se encuentra el punto medio del intervalo $c = \frac{a+b}{2}$.
3. Se evalúa la función en el punto c y si el cambio de signo sigue estando dentro del intervalo, cambiamos el intervalo para que c sea el nuevo b. Es decir, el intervalo será [a,c].
4. Repetimos el proceso desde que se halla el punto medio hasta llegar al valor deseado.

b. Realice la deducción del metodo de Newton-Rapshon, se recomienda escribir las ecuaciones en formato latex, para ello puede emplear las siguientes expresiones:

###**Deducción Método Newton-Raphson**
1. Partimos de un valor inicial $x_0$ cercano al valor $\alpha$ que hace nula la función.
2. Aplicamos la fórmula recursiva
\begin{equation}
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}  \text{ con }n = 0,1,2,...
\end{equation}
3. Hacemos uso de la expansión en series de Taylor para f alrededor de $x_n$, así:
\begin{equation}
f(x) = f(x_n) + f'(x_n)(x-x_n) + \frac{f''(\beta)}{2}(x-x-n)^2 \text{ donde } \beta \text{ es un punto entre } x\text{ y }x_n 
\end{equation}
4. Si hacemos  $x =\alpha$ obtenemos
\begin{equation}
0 = f(\alpha) = f(x_n) + f'(x_n)(x-x_n) + \frac{f''(\beta)}{2}(x-x-n)^2
\end{equation}
5. Despejando $\alpha$ tenemos que: 
\begin{equation}
\alpha = x_n - \frac{f(x_n)}{f'(x_n)} - \frac{f''(\beta)}{2f'(x_n)}(\alpha-x_n)^2
\end{equation}

c. ¿Cuál es la diferencia del metodo de Newton-Rapson con respecto al de la secante?

###**Método De La Secante**
1. La diferencia recae en que no se necesita conocer la derivada de la función
2. Se empieza nuevamente con la expansión por series de Taylor de la función $f(x)$
3. Se toman dos puntos cercanos a una raíz de la función $x_n$ y $x_{n-1}$ mediante los cuales podemos aproximar la función por una recta secante que pasa por esos puntos, empleando una aproximación con la definición de la derivada.
Tenemos: 
\begin{equation}
f(x) \approx f(x_n) + \frac{f(x_n) - f(x_{n-1})}{x_n - x_{n-1}}(x - x_n)
\end{equation}
4. Si igualamos a cero y despejamos $x$, obtenemos:
\begin{equation}
x_{n+1} = x_n - \frac{f(x_n)(x- x_{n-1})}{(f(x_n) - f(x_{n-1}))}
\end{equation}

d. Escriba en pseudocódigo los pasos para aplicar el método Punto Fijo.

###**Método De Punto Fijo**

1. Definir una función $g(x) = x - f(x)$
2. Defiinir $g(x_0) = x_0 - f(x_0) = x_0$
3. Definir el punto $p_0$, evaluar $g(p_0)$
4. Calcular el intercepto con la línea recta $p_1 = g(p_0), (g(p_0),g(p_0)$
5. Ir al punto $p_1$
6. El siguiente punto es $p_1,(p_1,g(p_1)$
7. Comparar $p_1$ con $g(p_1)$, si las condiciones no se satisfacen, repetir desde el paso 2, pero no con $p_1$

#2. Ceros de funciones
*Encontrar* los ceros de $e^{x}-2= \cos(e^x-2)$ por diferentes metodos, bisection, newton-rapshon, punto fijo.
"""

from scipy import optimize
import sympy as sp
import numpy as np
#Definamos la función.
def funcion(x):
  return np.exp(x)-2 - np.cos(np.exp(x)-2)
#Procedamos a definir dos valores de a,b para la función.
a = -1
b = 2
#Apliquemos el método bisect
raizBiseccion = optimize.bisect(funcion,a,b)
print(f'La raíz de la función por bisección es:  {raizBiseccion}')

#Ahora hagamos el proceso mediante Newton.
def funcion1(x):
  return sp.exp(x)-2 - sp.cos(sp.exp(x)-2)
x = sp.symbols('x')
y1 = funcion1(x)
yprima1 = sp.diff(y1)
print(f'La derivada de la función es:')
yprima1

#Ahora vamos a transformar objeto de sympy a numpy.
funcionLambda1 =  sp.lambdify(x,yprima1,'numpy')
#Y aplicamos el método de Newton.
raizNewton1 = optimize.newton(funcion,1, fprime= funcionLambda1)
print(f'La raíz mediante el método de Newton es: {raizNewton1}')

#Ahora lo vamos a hacer mediante el método de Punto Fijo.
def gdex1(x):
  return x - funcion(x)
raizPuntoFijo1 = optimize.fixed_point(gdex1,0.9)
print(f'La raíz por punto Fijo es: {raizPuntoFijo1}')

import matplotlib.pyplot as plt
x = np.linspace(-0,2)
y = funcion(x)
plt.grid()
plt.plot(x,y)
plt.axhline(y=0, xmin=0.1, xmax=0.9, color='red');

"""#3. Partícula en reposo
Una particula parte del reposo sobre un plano inclinado uniforme, cuyo ángulo 
$\theta$ cambia con una rapidez constante de : 

\begin{equation}
\frac{\mathrm{d}\theta}{\mathrm{d} t} = \omega < 0
\end{equation}

Al final de t segundos, la posición del objeto esta dada por: 


\begin{equation}
x(t) = -\frac{g}{2\omega^2} \left( \frac{e^{\omega t}-e^{-\omega t}}{2}-\sin\omega t\right) 
\end{equation}

Suponga que la particula se desplazo 0.51m en 1s. Encuentre, con exactitud de $10^{-5}$ la rapidez $\omega$ con que cambia $\theta$. Supoga $g=9.76$m/s

 
"""

#Definamos la función con los valores ya preestablecidos.
def funcionDeX(omega,tiempo=1,g=9.8):
  return (-g/(2*omega**2))*(((np.exp(omega*tiempo)-np.exp(-omega*tiempo))/2)- (np.sin(omega*tiempo)))

#Dejemos la expresión igualada a cero.
funcion = lambda omega: funcionDeX(omega)- 0.51
raiz = optimize.bisect(funcion,-1,-0.00001)
print(f'La rapidez omega es: {raiz}')

"""#3.  Area 
Hallar el área de un segmento circular cuya area sea igual a una cuarta parte del área del circulo. Para la solución se sugiere lo siguiente:

a) Encontrar la ecuacion trascendental.

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python.

c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre $[-2\pi, 2\pi]$. Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2*np.pi, 2*np.pi, 1000 )

d) Construir una segunda columna titulada "F_theta" con los registros f(theta)

f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz.

Estime el valor del ángulo empleando los siguientes metodos(Emplee  la documentacion):

g) [Bisección](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html)

h) [Newton-Rapshon](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)

i) [Secante](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) 

j) [Punto Fijo](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fixed_point.html)

a) Encontrar la ecuacion trascendental.\
El área del segmento circular es:

\begin{equation}
  \frac{R^2}{2} ( \theta-\sin(\theta))
\end{equation}

El cuarto del área de un círculo es:
\begin{equation}
 \frac{1}{4}\pi R^2
\end{equation} \
La función trascendental es:
\begin{equation}
 \frac{1}{2} ( \theta-\sin(\theta)) = \frac{1}{4}\pi
\end{equation} \

b) Con la ecuación anterior, definir una funcion $f(\theta)=0$. Emplee la funcion labmda de python
"""

funcion = lambda theta: ((1/2)*(theta-np.sin(theta))) - ((1/4)*np.pi)

"""c) Construir una data frame de pandas con la columna "theta" con 1000 registros(filas) entre  [−2π,2π] . Sugerencia, para construir el data frame emplee la función linspace como sigue : np.linspace(-2np.pi, 2np.pi, 1000 )"""

import pandas as pd
df = pd.DataFrame()
df['Theta'] = np.linspace(-2*np.pi,2*np.pi,1000)

"""d) Construir una segunda columna titulada "F_theta" con los registros f(theta)"""

df['F_theta'] = funcion(df['Theta'])
df

"""f) Realice un gráfico de  "F_theta" vs "theta". Identifique el intervalo de la raiz."""

import matplotlib.pyplot as plt
plt.plot(df['Theta'], df['F_theta'],'blue');
plt.title('F_theta vs theta');
plt.grid()
plt.axhline(y=0, xmin=0.1, xmax=0.9, color='red');
print('El intervalo de la raíz es cercano a: 2 y 3')

"""Estime el valor del ángulo empleando los siguientes metodos\
g) Bisección
"""

a = 2
b = 3
raiz = optimize.bisect(funcion,a,b)
print(f'La raíz de la función por bisección es:  {raiz}')

"""h) Newton"""

import sympy as sp
funcion1 = lambda theta: ((1/2)*(theta-sp.sin(theta))) - ((1/4)*sp.pi)
theta = sp.symbols('theta')
y1 = funcion1(theta)
yprima1 = sp.diff(y1)
print(f'La derivada de la función es:')
yprima1

#Ahora vamos a transformar objeto de sympy a numpy.
funcionLambda1 =  sp.lambdify(theta,yprima1,'numpy')
#Y aplicamos el método de Newton.
raizNewton1 = optimize.newton(funcion,1, fprime= funcionLambda1)
print(f'La raíz mediante el método de Newton es: {raizNewton1}')

"""i) Secante"""

#Hacemos uso del mismo método pero sin darle como parámetro la derivada
raizSecante = optimize.newton(funcion,1)
print(f'La raíz mediante el método de la secante es: {raizSecante}')

"""j) Punto Fijo."""

gdex2 = lambda tetha: tetha - funcion(tetha)
raizPuntoFijo2 = optimize.fixed_point(gdex2,2.3)
print(f'La raíz mediante punto fijo es: {raizPuntoFijo2}')

"""# 3. Movimiento de proyectiles en presencia de viento.

Supongamos que un proyectil es lanzado desde el origen con una rapidez $v=vo( \cos \theta , \sin \theta $. Supongamos además que el efecto del viento sobre el proyectil es el de una fuerza proporcional a la velocidad relativa entre el viento y el proyectil. Teniendo presente que si u es la velocidad del viento y $\alpha$ el ángulo que hace dirección de esta velocidad con el eje x, se puede entrontrar las siguientes ecuaciones diferenciales, asociada al estado de movimiento del [proyectil](https://iopscience.iop.org/article/10.1088/0143-0807/36/2/025016/meta):


\begin{equation}
m\frac{dv_x}{dt} = -mb(v_x-u\cos \alpha )
\end{equation}

\begin{equation}
m\frac{dv_y}{dt} = -mg-mb(v_x-u\sin \alpha ),
\end{equation}

donde b es el párametro de rozamiento. La soluciones a las ecuaciones anteriores vienen dadas por:

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}

Ver imagen:  http://www.sc.ehu.es/sbweb/fisica3/fluidos/viento/parabolico.html

###0. Establezca las siguietnes condiciones inciales.
"""

#Parámetros iniciales

v0 = 60 #Velocidad en m/s
alpha = np.pi #Angulo del viento
theta = np.deg2rad(45) #Angulo de lanzamiento
u = v0/2             #rapidez del viento
b = 0.05             #Parametro de friccion 
g = 9.8                #Aceleracion de la gravedad m/s2

Params = (alpha, v0, b, u,g)  #Parametros en tupla.

"""###1. Defina dos funciones, una para x y otra para y.

Posición en x
\begin{equation}
x=(u\cos \alpha) t + \frac{1}{b} (v_0\cos \theta_0 -u \cos\alpha)(1-\mathrm{exp}(-bt))
\end{equation}

Posicion en y 
\begin{equation}
y= \frac{1}{b}\left(\frac{g}{b}+v_0 \sin \theta_0 -u\sin\alpha \right)(1-\mathrm{exp}(-bt))-\left( \frac{g}{b}-u\sin\alpha\right)t
\end{equation}
"""

# Posicion en x
def pos_x(t, theta, alpha = np.pi, v0=60, b=0.05, u = v0/2,g=9.8):
  return (u*np.cos(alpha))*t + (1/b)*(v0*np.cos(theta) - u*np.cos(alpha))*(1-np.exp(-b*t))

# Posicion en y
def pos_y(t, theta, alpha = np.pi, v0=60, b=0.05, u = v0/2,g=9.8):
  y = (1/b)*((g/b) + v0*np.sin(theta)- u*np.sin(alpha))*(1- np.exp(-b*t)) - ((g/b)-u*np.sin(alpha))*t
  return y

"""2. Construya un diccionario con las claves "X", "Y", "Tiempo"
"""

diccionario = {'X':[],'Y':[],'Tiempo':[]}
diccionario

"""3. Con el diccionario construya un data frame de pandas llamado df con los nombres de columnas "X", "Y", "Tiempo"  https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.from_dict.html. Defina 1000 regitros para el intervalo de tiempo elegido."""

diccionario = {'X':[],'Y':[],'Tiempo':[]}
diccionario
df = pd.DataFrame(diccionario)
df['Tiempo'] = np.linspace(0,8.2,1000)
theta = np.deg2rad(45)
df['X'] = df['Tiempo'].apply(lambda tiempo: pos_x(tiempo,theta))
df['Y'] = df['Tiempo'].apply(lambda tiempo: pos_y(tiempo,theta))
df

"""4. Realice un gráfico de x como función del tiempo, de y como función del tiempo y la trayectoria de la partícula (df["X"], df["tiempo"], df["Y"])."""

import matplotlib.pyplot as plt
#Primero vamos a graficar a x y y como función del tiempo
fig, axs = plt.subplots(1, 2, figsize=(10, 4))
axs[0].plot(df['Tiempo'],df['X'])
axs[0].set_title('X como función de T')
axs[1].plot(df['Tiempo'], df['Y'])
axs[1].set_title('Y como función de T')
plt.grid();

#Código tomado de: https://pythondiario.com/2018/08/graficos-en-tercera-dimension-3d-con.html
# Modulos con los que trabajaremos
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
import numpy as np

# Creamos la figura
fig = plt.figure()

# Agrrgamos un plano 3D
ax1 = fig.add_subplot(111,projection='3d')

# Datos en array bi-dimensional
x = np.array([df['X']])
y = np.array([df['Y']])
t = np.array([df['Tiempo']])

# plot_wireframe nos permite agregar los datos x, y, z. Por ello 3D
# Es necesario que los datos esten contenidos en un array bi-dimensional
ax1.plot_wireframe(t, x, y)
# Mostramos el gráfico
plt.title('Trayectoria')
plt.show();

"""
5. Determine el alcance máximo de la partícula, para ello tome  la solucion teórica con $y=0$, solucione numéricamente la ecuación para t y remplace este valor en la ecuación para x. Resuelvalo para $\theta=45^{o}$.  """

#Encontremos el punto para el cual y = 0.
a = 8
b = 8.2
raiz = optimize.bisect(pos_y,a,b,args=(theta))
print(f'Y se hace cero en: {raiz}')
#Resolvamos la función en X.
alcanceMaximo = pos_x(raiz, theta)
print(f'El alcance máximo de la partícula es: {alcanceMaximo}')

"""6. Construya una  grafica del alcance máximo R como función de $\theta$, varie $\theta$  entre 10 y 80 grados cada 5 grados."""

angulos = np.array((range(10,80,5)))
angulos = np.deg2rad(angulos)
raices = []
raices.append(optimize.bisect(pos_y,2,3,args=(angulos[0])))                 
raices.append(optimize.bisect(pos_y,3,4,args=(angulos[1])))                 
raices.append(optimize.bisect(pos_y,4,5,args=(angulos[2])))      
raices.append(optimize.bisect(pos_y,4,5,args=(angulos[3])))
raices.append(optimize.bisect(pos_y,5,6,args=(angulos[4])))
raices.append(optimize.bisect(pos_y,6,7,args=(angulos[5])))
raices.append(optimize.bisect(pos_y,7,8,args=(angulos[6])))
raices.append(optimize.bisect(pos_y,8,9,args=(angulos[7])))
raices.append(optimize.bisect(pos_y,8,9,args=(angulos[8])))
raices.append(optimize.bisect(pos_y,9,10,args=(angulos[9])))
raices.append(optimize.bisect(pos_y,9,10,args=(angulos[10])))
raices.append(optimize.bisect(pos_y,10,11,args=(angulos[11])))
raices.append(optimize.bisect(pos_y,10,11,args=(angulos[12])))
raices.append(optimize.bisect(pos_y,10,11,args=(angulos[13])))
raices = np.array(raices)
alcancesMaximos = pos_x(raices, angulos)

angulosDecimales = np.rad2deg(angulos)
plt.plot(angulosDecimales,alcancesMaximos)
plt.title(f'Alcance máximo en función del ángulo ')
plt.grid();

"""
# 4. Construir un fractal empleando el metodo de Newton-Raphson, 
(Reproducir código y entender)
\begin{equation}
z_{n+1} = z_n -a \frac{f(z)}{f'(z)} 
\end{equation}



\begin{equation}
f'(z) = \frac{ f(z+h)+f(z) }{h}
\end{equation}"""

import numpy as np
import matplotlib.pylab as plt
from PIL import Image

Npx_X = 80 #Numero de pixeles en x
Npx_Y = 80 #Numero de pixeles en y

image = Image.new("RGB", (Npx_X, Npx_Y)) #Creacion de la imagen inicial

npx = np.arange(0, Npx_X)
npy = np.arange(0, Npx_Y)

xmin = -1
xmax = 1
ymin = -1
ymax = 1
#Transformación al plano complejo en un rectangulo (xmin, xmax), (ymin, ymax)
zx = npx * (xmax - xmin) / (Npx_X - 1)   + xmin
zy = npy * (ymax-ymin) / (Npx_Y - 1) + ymin

#Definicion  la funcion y las derivada 
def f(z): 
  return z**3 - 1

def fp(z): 
  return 3*z**2

h = 1E-4
def fpn(z, h): 
  return (f(z+h)-f(z))/h
  

a = 0.2
Niteraciones = 120
eps = 1E-8

x = - 1
for zx_ in zx:
  x = x + 1 
  y = -1
  for zy_ in zy: 
      y = y + 1
      Z_0 = complex(zx_, zy_)
    
      for i in range(0, Niteraciones): 
        Z = Z_0 - a * f(Z_0)/fp(Z_0)
        if( abs(Z-Z_0)<= eps):
          break           
        Z_0 = Z
      #print(i)
      #print(i)
      r, g, b = i % 4 *64 , i % 8 *16, i% 16* 16      
      image.putpixel((x,y), (r,g,b) )
plt.title('Fractal')
plt.imshow(image);
#plt.xlim(400, 600)
#plt.ylim(400, 523)