# -*- coding: utf-8 -*-
"""Actividad_04_Binarios_Errores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mxdCSIfT2rHZquWKu2XxnEoSp8cl0xE2

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Actividades_clase/Actividad_04_Binarios_Errores.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>



# Actividad 4
### Métodos computacionales para físicos  y astrónomos
### Universidad de Antioquia
### Prof: Hernan D. Salinas Jiménez
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/hernansalinas/autogrades.git
#path="libs"
path="autogrades/Actividades_clase/libs"
# %run -i {path}/libUnitTest.py

"""### Activity 1.0: 

Implement a function that get the binary representation of an integer with name mybin, the algorithm should return 
a string with 8 characters, the maximun number that represent the funcition is integer of 8 bit. The name of function is 
mybin

Ejexample : 

b=mybin(x)

b='00101000'
"""

##!/usr/bin/env python3
#Lo que está comentado es el código para implementar la parte decimal.
def mybin(x):
    #entero, decimal = str(x).split('.')
    #entero = int(entero)
    #decimal = float('.' + decimal)
    entero = x
    enteroBin = []
    #decimalBin = []
    while entero>=1:
      enteroBin.append(entero%2)
      entero = entero//2
    #while decimal<1:
      #decimalBin.append(0)
      #decimal = decimal*2
    #decimalBin.append(1)
    entero = ''.join(str(i) for i in enteroBin[::-1])
    entero = entero.rjust(8,'0')
    return entero

mybin(234)

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test01.py

"""### Activity 2.0: 

With the binary representation please try to implement the formula to recover the number.

Hint: Use as input the binary representation as a string and invert its order

```
number32(BIN):

```

Where BIN is a string with the binary number

Example: 


Test your solution for the next number:

number32("00111110001000000000001000010000")
"""

import numpy as np
def number32(BIN):
  #Vamos a invertir la lista
  numeros_invertidos = np.array(list(BIN)[::-1]).astype(int)
  signo = numeros_invertidos[31]
  #Parte Fraccionarios
  fracc = numeros_invertidos[0:23]
  #Parte exponencial
  expo = numeros_invertidos[23:31]
  #Creamos un arreglo del tamaño de los numeros exp para operar y sacar el e.
  i = np.arange(expo.size)
  #Aplicamos la formula.
  e = (expo*(2**i)).sum()
  # Realizamos la sumatoria general
  i_invertida = np.arange(1,fracc.size+1)[::-1]
  decimal = ((-1)**signo)/2**(127-e)*(1+(fracc/2**i_invertida).sum())
  return decimal
number32("00111110001000000000001000010000")

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test02.py

"""### Activity 3.0:
1. Write a python script that calculates the double precision number represented by a 64-bits binary.

the name of function should be: 
```
number64(BIN):

```

2. What is the number represented by:

BIN="0 10000000011 1011100100001111111111111111111111111111111111111111"
"""

def number64(BIN):
  # Vamos a invertir la lista
  numeros_invertidos = np.array(list(BIN)[::-1]).astype(int)
  signo = numeros_invertidos[31]
  # Parte Fraccionarios
  fracc = numeros_invertidos[0:52][::-1]
  # Parte exponencial
  expo = numeros_invertidos[52:63][::-1]
  # Creamos un arreglo del tamaño de los numeros exp para operar y sacar el e.
  i = np.arange(expo.size)
  # Aplicamos la formula.
  e = (expo*(2**i)).sum()
  # Realizamos la sumatoria general
  i_invertida = np.arange(1,53)
  decimal = ((-1)**signo * (1 + (fracc / 2**i_invertida).sum()) * (2**(e-1023)))
  return decimal

number64('1011100100001111111111111111111111111111111111111111')

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test03.py